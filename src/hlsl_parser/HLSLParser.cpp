/** \file
 *  This C++ source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : HLSL.g
 *     -                            On : 2012-06-14 16:58:03
 *     -                for the parser : HLSLParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy lifting from C Run-time by Jim Idle )
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram, ElectronDB
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "HLSLParser.hpp"
/* ----------------------------------------- */


/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

using namespace antlr3;
/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
ANTLR_UINT8*   HLSLParserTokenNames[41+4]
     = {
        (ANTLR_UINT8*) "<invalid>",       /* String to print to indicate an invalid token */
        (ANTLR_UINT8*) "<EOR>",
        (ANTLR_UINT8*) "<DOWN>",
        (ANTLR_UINT8*) "<UP>",
        (ANTLR_UINT8*) "COMMENT",
        (ANTLR_UINT8*) "ESC_SEQ",
        (ANTLR_UINT8*) "EXPONENT",
        (ANTLR_UINT8*) "FLOAT",
        (ANTLR_UINT8*) "HEX_DIGIT",
        (ANTLR_UINT8*) "ID",
        (ANTLR_UINT8*) "INT",
        (ANTLR_UINT8*) "LEFT_CURLY",
        (ANTLR_UINT8*) "OCTAL_ESC",
        (ANTLR_UINT8*) "RIGHT_CURLY",
        (ANTLR_UINT8*) "STRING",
        (ANTLR_UINT8*) "WS",
        (ANTLR_UINT8*) "'('",
        (ANTLR_UINT8*) "')'",
        (ANTLR_UINT8*) "','",
        (ANTLR_UINT8*) "'.'",
        (ANTLR_UINT8*) "':'",
        (ANTLR_UINT8*) "';'",
        (ANTLR_UINT8*) "'<'",
        (ANTLR_UINT8*) "'='",
        (ANTLR_UINT8*) "'>'",
        (ANTLR_UINT8*) "'COLOR0'",
        (ANTLR_UINT8*) "'POSITION'",
        (ANTLR_UINT8*) "'PixelShader'",
        (ANTLR_UINT8*) "'TEXCOORD0'",
        (ANTLR_UINT8*) "'Texture'",
        (ANTLR_UINT8*) "'VertexShader'",
        (ANTLR_UINT8*) "'compile'",
        (ANTLR_UINT8*) "'float'",
        (ANTLR_UINT8*) "'float1x1'",
        (ANTLR_UINT8*) "'float1x2'",
        (ANTLR_UINT8*) "'float2'",
        (ANTLR_UINT8*) "'float3'",
        (ANTLR_UINT8*) "'float4'",
        (ANTLR_UINT8*) "'pass'",
        (ANTLR_UINT8*) "'ps_3_0'",
        (ANTLR_UINT8*) "'return'",
        (ANTLR_UINT8*) "'sampler2D'",
        (ANTLR_UINT8*) "'struct'",
        (ANTLR_UINT8*) "'technique'",
        (ANTLR_UINT8*) "'vs_3_0'"
       };


/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "HLSL.g";

/** \brief Return the name of the grammar file that generated this code.
 */
const char* HLSLParser::getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new HLSLParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
HLSLParser::HLSLParser( StreamType* instream)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, NULL)

{
	// See if we can create a new parser with the standard constructor
	//
	this->init(instream);
}

/** \brief Create a new HLSLParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
HLSLParser::HLSLParser( StreamType* instream, RecognizerSharedStateType* state)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, state)

{
	this->init(instream );
}

void HLSLParser::init(StreamType* instream)
{
	/* Install the token table
	*/
	this->get_psrstate()->set_tokenNames( HLSLParserTokenNames );


}

void
HLSLParser::reset()
{
    this->get_rec()->reset();
}

/** Free the parser resources
 */
HLSLParser::~HLSLParser()
 {
}

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static ANTLR_UINT8**	getTokenNames()
{
        return HLSLParserTokenNames;
}

/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_global_declaration_in_translation_unit66_bits[]	= { ANTLR_UINT64_LIT(0x00000E3F20000202) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_global_declaration_in_translation_unit66( FOLLOW_global_declaration_in_translation_unit66_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_technique_in_translation_unit69_bits[]	= { ANTLR_UINT64_LIT(0x0000080000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_technique_in_translation_unit69( FOLLOW_technique_in_translation_unit69_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_type_definition_in_global_declaration82_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_type_definition_in_global_declaration82( FOLLOW_type_definition_in_global_declaration82_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_variable_declaration_in_global_declaration87_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_variable_declaration_in_global_declaration87( FOLLOW_variable_declaration_in_global_declaration87_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_function_in_global_declaration92_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_function_in_global_declaration92( FOLLOW_function_in_global_declaration92_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_43_in_technique104_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000200) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_43_in_technique104( FOLLOW_43_in_technique104_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_ID_in_technique106_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000800) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_ID_in_technique106( FOLLOW_ID_in_technique106_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_CURLY_in_technique108_bits[]	= { ANTLR_UINT64_LIT(0x0000004000002000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_LEFT_CURLY_in_technique108( FOLLOW_LEFT_CURLY_in_technique108_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_pass_in_technique114_bits[]	= { ANTLR_UINT64_LIT(0x0000004000002000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_pass_in_technique114( FOLLOW_pass_in_technique114_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_CURLY_in_technique119_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_RIGHT_CURLY_in_technique119( FOLLOW_RIGHT_CURLY_in_technique119_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_38_in_pass132_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000200) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_38_in_pass132( FOLLOW_38_in_pass132_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_ID_in_pass134_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000800) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_ID_in_pass134( FOLLOW_ID_in_pass134_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_CURLY_in_pass138_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_LEFT_CURLY_in_pass138( FOLLOW_LEFT_CURLY_in_pass138_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_vertex_shader_definition_in_pass140_bits[]	= { ANTLR_UINT64_LIT(0x0000000008000000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_vertex_shader_definition_in_pass140( FOLLOW_vertex_shader_definition_in_pass140_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_pixel_shader_definition_in_pass142_bits[]	= { ANTLR_UINT64_LIT(0x0000000000002000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_pixel_shader_definition_in_pass142( FOLLOW_pixel_shader_definition_in_pass142_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_CURLY_in_pass144_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_RIGHT_CURLY_in_pass144( FOLLOW_RIGHT_CURLY_in_pass144_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_30_in_vertex_shader_definition158_bits[]	= { ANTLR_UINT64_LIT(0x0000000000800000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_30_in_vertex_shader_definition158( FOLLOW_30_in_vertex_shader_definition158_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_23_in_vertex_shader_definition160_bits[]	= { ANTLR_UINT64_LIT(0x0000000080000000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_23_in_vertex_shader_definition160( FOLLOW_23_in_vertex_shader_definition160_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_31_in_vertex_shader_definition162_bits[]	= { ANTLR_UINT64_LIT(0x0000100000000000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_31_in_vertex_shader_definition162( FOLLOW_31_in_vertex_shader_definition162_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_44_in_vertex_shader_definition164_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000200) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_44_in_vertex_shader_definition164( FOLLOW_44_in_vertex_shader_definition164_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_ID_in_vertex_shader_definition166_bits[]	= { ANTLR_UINT64_LIT(0x0000000000010000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_ID_in_vertex_shader_definition166( FOLLOW_ID_in_vertex_shader_definition166_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_16_in_vertex_shader_definition168_bits[]	= { ANTLR_UINT64_LIT(0x0000000000020000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_16_in_vertex_shader_definition168( FOLLOW_16_in_vertex_shader_definition168_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_17_in_vertex_shader_definition170_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_17_in_vertex_shader_definition170( FOLLOW_17_in_vertex_shader_definition170_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_21_in_vertex_shader_definition172_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_21_in_vertex_shader_definition172( FOLLOW_21_in_vertex_shader_definition172_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_27_in_pixel_shader_definition194_bits[]	= { ANTLR_UINT64_LIT(0x0000000000800000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_27_in_pixel_shader_definition194( FOLLOW_27_in_pixel_shader_definition194_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_23_in_pixel_shader_definition196_bits[]	= { ANTLR_UINT64_LIT(0x0000000080000000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_23_in_pixel_shader_definition196( FOLLOW_23_in_pixel_shader_definition196_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_31_in_pixel_shader_definition198_bits[]	= { ANTLR_UINT64_LIT(0x0000008000000000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_31_in_pixel_shader_definition198( FOLLOW_31_in_pixel_shader_definition198_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_39_in_pixel_shader_definition200_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000200) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_39_in_pixel_shader_definition200( FOLLOW_39_in_pixel_shader_definition200_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_ID_in_pixel_shader_definition202_bits[]	= { ANTLR_UINT64_LIT(0x0000000000010000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_ID_in_pixel_shader_definition202( FOLLOW_ID_in_pixel_shader_definition202_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_16_in_pixel_shader_definition204_bits[]	= { ANTLR_UINT64_LIT(0x0000000000020000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_16_in_pixel_shader_definition204( FOLLOW_16_in_pixel_shader_definition204_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_17_in_pixel_shader_definition206_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_17_in_pixel_shader_definition206( FOLLOW_17_in_pixel_shader_definition206_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_21_in_pixel_shader_definition208_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_21_in_pixel_shader_definition208( FOLLOW_21_in_pixel_shader_definition208_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_42_in_type_definition218_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000200) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_42_in_type_definition218( FOLLOW_42_in_type_definition218_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_ID_in_type_definition220_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000800) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_ID_in_type_definition220( FOLLOW_ID_in_type_definition220_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_CURLY_in_type_definition222_bits[]	= { ANTLR_UINT64_LIT(0x0000003F00000200) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_LEFT_CURLY_in_type_definition222( FOLLOW_LEFT_CURLY_in_type_definition222_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_field_declaration_in_type_definition226_bits[]	= { ANTLR_UINT64_LIT(0x0000003F00002200) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_field_declaration_in_type_definition226( FOLLOW_field_declaration_in_type_definition226_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_CURLY_in_type_definition229_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_RIGHT_CURLY_in_type_definition229( FOLLOW_RIGHT_CURLY_in_type_definition229_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_21_in_type_definition231_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_21_in_type_definition231( FOLLOW_21_in_type_definition231_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_type_in_variable_declaration245_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000200) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_type_in_variable_declaration245( FOLLOW_type_in_variable_declaration245_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_ID_in_variable_declaration247_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_ID_in_variable_declaration247( FOLLOW_ID_in_variable_declaration247_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_21_in_variable_declaration249_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_21_in_variable_declaration249( FOLLOW_21_in_variable_declaration249_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_texture_type_in_variable_declaration255_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000200) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_texture_type_in_variable_declaration255( FOLLOW_texture_type_in_variable_declaration255_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_ID_in_variable_declaration257_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_ID_in_variable_declaration257( FOLLOW_ID_in_variable_declaration257_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_21_in_variable_declaration259_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_21_in_variable_declaration259( FOLLOW_21_in_variable_declaration259_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_sampler_in_variable_declaration266_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_sampler_in_variable_declaration266( FOLLOW_sampler_in_variable_declaration266_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_sampler_type_in_sampler277_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000200) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_sampler_type_in_sampler277( FOLLOW_sampler_type_in_sampler277_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_ID_in_sampler279_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000800) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_ID_in_sampler279( FOLLOW_ID_in_sampler279_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_CURLY_in_sampler281_bits[]	= { ANTLR_UINT64_LIT(0x0000000020002200) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_LEFT_CURLY_in_sampler281( FOLLOW_LEFT_CURLY_in_sampler281_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_sampler_parameter_in_sampler283_bits[]	= { ANTLR_UINT64_LIT(0x0000000020002200) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_sampler_parameter_in_sampler283( FOLLOW_sampler_parameter_in_sampler283_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_CURLY_in_sampler286_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_RIGHT_CURLY_in_sampler286( FOLLOW_RIGHT_CURLY_in_sampler286_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_21_in_sampler288_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_21_in_sampler288( FOLLOW_21_in_sampler288_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_41_in_sampler_type301_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_41_in_sampler_type301( FOLLOW_41_in_sampler_type301_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_29_in_sampler_parameter313_bits[]	= { ANTLR_UINT64_LIT(0x0000000000800000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_29_in_sampler_parameter313( FOLLOW_29_in_sampler_parameter313_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_23_in_sampler_parameter315_bits[]	= { ANTLR_UINT64_LIT(0x0000000000400000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_23_in_sampler_parameter315( FOLLOW_23_in_sampler_parameter315_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_22_in_sampler_parameter317_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000200) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_22_in_sampler_parameter317( FOLLOW_22_in_sampler_parameter317_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_ID_in_sampler_parameter319_bits[]	= { ANTLR_UINT64_LIT(0x0000000001000000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_ID_in_sampler_parameter319( FOLLOW_ID_in_sampler_parameter319_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_24_in_sampler_parameter321_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_24_in_sampler_parameter321( FOLLOW_24_in_sampler_parameter321_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_21_in_sampler_parameter323_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_21_in_sampler_parameter323( FOLLOW_21_in_sampler_parameter323_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_ID_in_sampler_parameter328_bits[]	= { ANTLR_UINT64_LIT(0x0000000000800000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_ID_in_sampler_parameter328( FOLLOW_ID_in_sampler_parameter328_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_23_in_sampler_parameter330_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000200) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_23_in_sampler_parameter330( FOLLOW_23_in_sampler_parameter330_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_ID_in_sampler_parameter332_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_ID_in_sampler_parameter332( FOLLOW_ID_in_sampler_parameter332_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_21_in_sampler_parameter334_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_21_in_sampler_parameter334( FOLLOW_21_in_sampler_parameter334_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_29_in_texture_type383_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_29_in_texture_type383( FOLLOW_29_in_texture_type383_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_number_type_in_type393_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_number_type_in_type393( FOLLOW_number_type_in_type393_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_ID_in_type398_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_ID_in_type398( FOLLOW_ID_in_type398_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_type_in_field_declaration411_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000200) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_type_in_field_declaration411( FOLLOW_type_in_field_declaration411_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_ID_in_field_declaration413_bits[]	= { ANTLR_UINT64_LIT(0x0000000000100000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_ID_in_field_declaration413( FOLLOW_ID_in_field_declaration413_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_20_in_field_declaration415_bits[]	= { ANTLR_UINT64_LIT(0x0000000016000000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_20_in_field_declaration415( FOLLOW_20_in_field_declaration415_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_semantic_in_field_declaration417_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_semantic_in_field_declaration417( FOLLOW_semantic_in_field_declaration417_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_21_in_field_declaration419_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_21_in_field_declaration419( FOLLOW_21_in_field_declaration419_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_type_in_function466_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000200) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_type_in_function466( FOLLOW_type_in_function466_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_ID_in_function468_bits[]	= { ANTLR_UINT64_LIT(0x0000000000010000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_ID_in_function468( FOLLOW_ID_in_function468_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_16_in_function470_bits[]	= { ANTLR_UINT64_LIT(0x0000003F00020200) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_16_in_function470( FOLLOW_16_in_function470_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_parameter_declaration_in_function482_bits[]	= { ANTLR_UINT64_LIT(0x0000000000060000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_parameter_declaration_in_function482( FOLLOW_parameter_declaration_in_function482_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_18_in_function491_bits[]	= { ANTLR_UINT64_LIT(0x0000003F00000200) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_18_in_function491( FOLLOW_18_in_function491_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_parameter_declaration_in_function497_bits[]	= { ANTLR_UINT64_LIT(0x0000000000060000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_parameter_declaration_in_function497( FOLLOW_parameter_declaration_in_function497_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_17_in_function511_bits[]	= { ANTLR_UINT64_LIT(0x0000000000100800) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_17_in_function511( FOLLOW_17_in_function511_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_20_in_function515_bits[]	= { ANTLR_UINT64_LIT(0x0000000016000000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_20_in_function515( FOLLOW_20_in_function515_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_semantic_in_function517_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000800) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_semantic_in_function517( FOLLOW_semantic_in_function517_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_CURLY_in_function522_bits[]	= { ANTLR_UINT64_LIT(0x0000033F20002680) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_LEFT_CURLY_in_function522( FOLLOW_LEFT_CURLY_in_function522_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_statement_in_function533_bits[]	= { ANTLR_UINT64_LIT(0x0000033F20002680) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_statement_in_function533( FOLLOW_statement_in_function533_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_CURLY_in_function549_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_RIGHT_CURLY_in_function549( FOLLOW_RIGHT_CURLY_in_function549_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_type_in_parameter_declaration563_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000200) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_type_in_parameter_declaration563( FOLLOW_type_in_parameter_declaration563_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_ID_in_parameter_declaration565_bits[]	= { ANTLR_UINT64_LIT(0x0000000000100002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_ID_in_parameter_declaration565( FOLLOW_ID_in_parameter_declaration565_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_20_in_parameter_declaration571_bits[]	= { ANTLR_UINT64_LIT(0x0000000016000000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_20_in_parameter_declaration571( FOLLOW_20_in_parameter_declaration571_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_semantic_in_parameter_declaration573_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_semantic_in_parameter_declaration573( FOLLOW_semantic_in_parameter_declaration573_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_variable_declaration_in_statement589_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_variable_declaration_in_statement589( FOLLOW_variable_declaration_in_statement589_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_40_in_statement594_bits[]	= { ANTLR_UINT64_LIT(0x0000003F00000680) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_40_in_statement594( FOLLOW_40_in_statement594_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_exp_in_statement596_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_exp_in_statement596( FOLLOW_exp_in_statement596_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_21_in_statement598_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_21_in_statement598( FOLLOW_21_in_statement598_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_exp_in_statement605_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_exp_in_statement605( FOLLOW_exp_in_statement605_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_21_in_statement607_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_21_in_statement607( FOLLOW_21_in_statement607_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_function_call_in_exp617_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_function_call_in_exp617( FOLLOW_function_call_in_exp617_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_variable_in_exp622_bits[]	= { ANTLR_UINT64_LIT(0x0000000000800002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_variable_in_exp622( FOLLOW_variable_in_exp622_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_23_in_exp625_bits[]	= { ANTLR_UINT64_LIT(0x0000003F00000680) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_23_in_exp625( FOLLOW_23_in_exp625_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_exp_in_exp627_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_exp_in_exp627( FOLLOW_exp_in_exp627_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_constructor_in_exp634_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_constructor_in_exp634( FOLLOW_constructor_in_exp634_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_number_in_exp639_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_number_in_exp639( FOLLOW_number_in_exp639_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_ID_in_variable652_bits[]	= { ANTLR_UINT64_LIT(0x0000000000080000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_ID_in_variable652( FOLLOW_ID_in_variable652_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_19_in_variable654_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000200) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_19_in_variable654( FOLLOW_19_in_variable654_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_variable_in_variable656_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_variable_in_variable656( FOLLOW_variable_in_variable656_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_ID_in_variable661_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_ID_in_variable661( FOLLOW_ID_in_variable661_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_ID_in_function_call671_bits[]	= { ANTLR_UINT64_LIT(0x0000000000010000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_ID_in_function_call671( FOLLOW_ID_in_function_call671_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_16_in_function_call673_bits[]	= { ANTLR_UINT64_LIT(0x0000003F00020680) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_16_in_function_call673( FOLLOW_16_in_function_call673_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_exp_in_function_call677_bits[]	= { ANTLR_UINT64_LIT(0x0000000000060000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_exp_in_function_call677( FOLLOW_exp_in_function_call677_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_18_in_function_call681_bits[]	= { ANTLR_UINT64_LIT(0x0000003F00000680) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_18_in_function_call681( FOLLOW_18_in_function_call681_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_exp_in_function_call683_bits[]	= { ANTLR_UINT64_LIT(0x0000000000060000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_exp_in_function_call683( FOLLOW_exp_in_function_call683_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_17_in_function_call691_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_17_in_function_call691( FOLLOW_17_in_function_call691_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_number_type_in_constructor704_bits[]	= { ANTLR_UINT64_LIT(0x0000000000010000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_number_type_in_constructor704( FOLLOW_number_type_in_constructor704_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_16_in_constructor706_bits[]	= { ANTLR_UINT64_LIT(0x0000003F00000680) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_16_in_constructor706( FOLLOW_16_in_constructor706_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_exp_in_constructor708_bits[]	= { ANTLR_UINT64_LIT(0x0000000000060000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_exp_in_constructor708( FOLLOW_exp_in_constructor708_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_18_in_constructor713_bits[]	= { ANTLR_UINT64_LIT(0x0000003F00000680) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_18_in_constructor713( FOLLOW_18_in_constructor713_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_exp_in_constructor715_bits[]	= { ANTLR_UINT64_LIT(0x0000000000060000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_exp_in_constructor715( FOLLOW_exp_in_constructor715_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_17_in_constructor720_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_17_in_constructor720( FOLLOW_17_in_constructor720_bits, 1 );


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start translation_unit
 * HLSL.g:41:1: translation_unit : ( global_declaration )* ( technique )* ;
 */
void
HLSLParser::translation_unit()
{
        HLSLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // HLSL.g:42:2: ( ( global_declaration )* ( technique )* )
        // HLSL.g:42:4: ( global_declaration )* ( technique )*
        {
            // HLSL.g:42:4: ( global_declaration )*

            for (;;)
            {
                int alt1=2;
                switch ( this->LA(1) )
                {
                case ID:
                case 29:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                case 37:
                case 41:
                case 42:
                	{
                		alt1=1;
                	}
                    break;

                }

                switch (alt1)
                {
            	case 1:
            	    // HLSL.g:42:4: global_declaration
            	    {
            	        this->followPush(FOLLOW_global_declaration_in_translation_unit66);
            	        global_declaration();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletranslation_unitEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop1;	/* break out of the loop */
            	    break;
                }
            }
            loop1: ; /* Jump out to here if this rule does not match */


            // HLSL.g:42:24: ( technique )*

            for (;;)
            {
                int alt2=2;
                switch ( this->LA(1) )
                {
                case 43:
                	{
                		alt2=1;
                	}
                    break;

                }

                switch (alt2)
                {
            	case 1:
            	    // HLSL.g:42:24: technique
            	    {
            	        this->followPush(FOLLOW_technique_in_translation_unit69);
            	        technique();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletranslation_unitEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop2;	/* break out of the loop */
            	    break;
                }
            }
            loop2: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletranslation_unitEx; /* Prevent compiler warnings */
    ruletranslation_unitEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end translation_unit */

/**
 * $ANTLR start global_declaration
 * HLSL.g:45:1: global_declaration : ( type_definition | variable_declaration | function );
 */
void
HLSLParser::global_declaration()
{
        HLSLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  HLSL.g:46:2: ( type_definition | variable_declaration | function )

            ANTLR_UINT32 alt3;

            alt3=3;

            switch ( this->LA(1) )
            {
            case 42:
            	{
            		alt3=1;
            	}
                break;
            case 32:
            case 33:
            case 34:
            case 35:
            case 36:
            case 37:
            	{
            		switch ( this->LA(2) )
            		{
            		case ID:
            			{
            				switch ( this->LA(3) )
            				{
            				case 21:
            					{
            						alt3=2;
            					}
            				    break;
            				case 16:
            					{
            						alt3=3;
            					}
            				    break;

            				default:
            				    if (this->get_backtracking()>0)
            				    {
            				        this->set_failedflag( true );
            				        return ;
            				    }

            				    ExceptionBaseType* ex = new ANTLR_Exception< HLSLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            				    ex->set_decisionNum( 3 );
            				    ex->set_state( 5 );


            				    goto ruleglobal_declarationEx;

            				}

            			}
            		    break;

            		default:
            		    if (this->get_backtracking()>0)
            		    {
            		        this->set_failedflag( true );
            		        return ;
            		    }

            		    ExceptionBaseType* ex = new ANTLR_Exception< HLSLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 3 );
            		    ex->set_state( 2 );


            		    goto ruleglobal_declarationEx;

            		}

            	}
                break;
            case ID:
            	{
            		switch ( this->LA(2) )
            		{
            		case ID:
            			{
            				switch ( this->LA(3) )
            				{
            				case 21:
            					{
            						alt3=2;
            					}
            				    break;
            				case 16:
            					{
            						alt3=3;
            					}
            				    break;

            				default:
            				    if (this->get_backtracking()>0)
            				    {
            				        this->set_failedflag( true );
            				        return ;
            				    }

            				    ExceptionBaseType* ex = new ANTLR_Exception< HLSLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            				    ex->set_decisionNum( 3 );
            				    ex->set_state( 5 );


            				    goto ruleglobal_declarationEx;

            				}

            			}
            		    break;

            		default:
            		    if (this->get_backtracking()>0)
            		    {
            		        this->set_failedflag( true );
            		        return ;
            		    }

            		    ExceptionBaseType* ex = new ANTLR_Exception< HLSLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 3 );
            		    ex->set_state( 3 );


            		    goto ruleglobal_declarationEx;

            		}

            	}
                break;
            case 29:
            case 41:
            	{
            		alt3=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< HLSLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 3 );
                ex->set_state( 0 );


                goto ruleglobal_declarationEx;

            }

            switch (alt3)
            {
        	case 1:
        	    // HLSL.g:46:4: type_definition
        	    {
        	        this->followPush(FOLLOW_type_definition_in_global_declaration82);
        	        type_definition();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleglobal_declarationEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // HLSL.g:47:4: variable_declaration
        	    {
        	        this->followPush(FOLLOW_variable_declaration_in_global_declaration87);
        	        variable_declaration();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleglobal_declarationEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // HLSL.g:48:4: function
        	    {
        	        this->followPush(FOLLOW_function_in_global_declaration92);
        	        function();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleglobal_declarationEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleglobal_declarationEx; /* Prevent compiler warnings */
    ruleglobal_declarationEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end global_declaration */

/**
 * $ANTLR start technique
 * HLSL.g:51:1: technique : 'technique' ID LEFT_CURLY ( pass )* RIGHT_CURLY ;
 */
void
HLSLParser::technique()
{
        HLSLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    const CommonTokenType*    ID1;

    /* Initialize rule variables
     */

    ID1       = NULL;


 
    {
        // HLSL.g:52:2: ( 'technique' ID LEFT_CURLY ( pass )* RIGHT_CURLY )
        // HLSL.g:52:4: 'technique' ID LEFT_CURLY ( pass )* RIGHT_CURLY
        {
             this->matchToken(43, &FOLLOW_43_in_technique104);
            if  (this->hasException())
            {
                goto ruletechniqueEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            ID1 =  this->matchToken(ID, &FOLLOW_ID_in_technique106);
            if  (this->hasException())
            {
                goto ruletechniqueEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_CURLY, &FOLLOW_LEFT_CURLY_in_technique108);
            if  (this->hasException())
            {
                goto ruletechniqueEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            if ( this->get_backtracking()==0 )
            {
                 Listener->StartTechnique( (ID1->getText()) ); 
            }


            // HLSL.g:52:72: ( pass )*

            for (;;)
            {
                int alt4=2;
                switch ( this->LA(1) )
                {
                case 38:
                	{
                		alt4=1;
                	}
                    break;

                }

                switch (alt4)
                {
            	case 1:
            	    // HLSL.g:52:74: pass
            	    {
            	        this->followPush(FOLLOW_pass_in_technique114);
            	        pass();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletechniqueEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop4;	/* break out of the loop */
            	    break;
                }
            }
            loop4: ; /* Jump out to here if this rule does not match */


             this->matchToken(RIGHT_CURLY, &FOLLOW_RIGHT_CURLY_in_technique119);
            if  (this->hasException())
            {
                goto ruletechniqueEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            if ( this->get_backtracking()==0 )
            {
                 Listener->EndTechnique(); 
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletechniqueEx; /* Prevent compiler warnings */
    ruletechniqueEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end technique */

/**
 * $ANTLR start pass
 * HLSL.g:55:1: pass : 'pass' ID LEFT_CURLY vertex_shader_definition pixel_shader_definition RIGHT_CURLY ;
 */
void
HLSLParser::pass()
{
        HLSLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    const CommonTokenType*    ID2;

    /* Initialize rule variables
     */

    ID2       = NULL;


 
    {
        // HLSL.g:55:7: ( 'pass' ID LEFT_CURLY vertex_shader_definition pixel_shader_definition RIGHT_CURLY )
        // HLSL.g:55:9: 'pass' ID LEFT_CURLY vertex_shader_definition pixel_shader_definition RIGHT_CURLY
        {
             this->matchToken(38, &FOLLOW_38_in_pass132);
            if  (this->hasException())
            {
                goto rulepassEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            ID2 =  this->matchToken(ID, &FOLLOW_ID_in_pass134);
            if  (this->hasException())
            {
                goto rulepassEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            if ( this->get_backtracking()==0 )
            {
                 Listener->StartPass( (ID2->getText()) ); 
            }


             this->matchToken(LEFT_CURLY, &FOLLOW_LEFT_CURLY_in_pass138);
            if  (this->hasException())
            {
                goto rulepassEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_vertex_shader_definition_in_pass140);
            vertex_shader_definition();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepassEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_pixel_shader_definition_in_pass142);
            pixel_shader_definition();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepassEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(RIGHT_CURLY, &FOLLOW_RIGHT_CURLY_in_pass144);
            if  (this->hasException())
            {
                goto rulepassEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            if ( this->get_backtracking()==0 )
            {
                 Listener->EndPass(); 
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepassEx; /* Prevent compiler warnings */
    rulepassEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end pass */

/**
 * $ANTLR start vertex_shader_definition
 * HLSL.g:58:1: vertex_shader_definition : 'VertexShader' '=' 'compile' 'vs_3_0' ID '(' ')' ';' ;
 */
void
HLSLParser::vertex_shader_definition()
{
        HLSLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    const CommonTokenType*    ID3;

    /* Initialize rule variables
     */

    ID3       = NULL;


 
    {
        // HLSL.g:59:2: ( 'VertexShader' '=' 'compile' 'vs_3_0' ID '(' ')' ';' )
        // HLSL.g:59:4: 'VertexShader' '=' 'compile' 'vs_3_0' ID '(' ')' ';'
        {
             this->matchToken(30, &FOLLOW_30_in_vertex_shader_definition158);
            if  (this->hasException())
            {
                goto rulevertex_shader_definitionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(23, &FOLLOW_23_in_vertex_shader_definition160);
            if  (this->hasException())
            {
                goto rulevertex_shader_definitionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(31, &FOLLOW_31_in_vertex_shader_definition162);
            if  (this->hasException())
            {
                goto rulevertex_shader_definitionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(44, &FOLLOW_44_in_vertex_shader_definition164);
            if  (this->hasException())
            {
                goto rulevertex_shader_definitionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            ID3 =  this->matchToken(ID, &FOLLOW_ID_in_vertex_shader_definition166);
            if  (this->hasException())
            {
                goto rulevertex_shader_definitionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(16, &FOLLOW_16_in_vertex_shader_definition168);
            if  (this->hasException())
            {
                goto rulevertex_shader_definitionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(17, &FOLLOW_17_in_vertex_shader_definition170);
            if  (this->hasException())
            {
                goto rulevertex_shader_definitionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(21, &FOLLOW_21_in_vertex_shader_definition172);
            if  (this->hasException())
            {
                goto rulevertex_shader_definitionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            if ( this->get_backtracking()==0 )
            {
                 Listener->SetVertexShader( (ID3->getText()) ); 
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulevertex_shader_definitionEx; /* Prevent compiler warnings */
    rulevertex_shader_definitionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end vertex_shader_definition */

/**
 * $ANTLR start pixel_shader_definition
 * HLSL.g:61:1: pixel_shader_definition : 'PixelShader' '=' 'compile' 'ps_3_0' ID '(' ')' ';' ;
 */
void
HLSLParser::pixel_shader_definition()
{
        HLSLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    const CommonTokenType*    ID4;

    /* Initialize rule variables
     */

    ID4       = NULL;


 
    {
        // HLSL.g:62:2: ( 'PixelShader' '=' 'compile' 'ps_3_0' ID '(' ')' ';' )
        // HLSL.g:62:7: 'PixelShader' '=' 'compile' 'ps_3_0' ID '(' ')' ';'
        {
             this->matchToken(27, &FOLLOW_27_in_pixel_shader_definition194);
            if  (this->hasException())
            {
                goto rulepixel_shader_definitionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(23, &FOLLOW_23_in_pixel_shader_definition196);
            if  (this->hasException())
            {
                goto rulepixel_shader_definitionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(31, &FOLLOW_31_in_pixel_shader_definition198);
            if  (this->hasException())
            {
                goto rulepixel_shader_definitionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(39, &FOLLOW_39_in_pixel_shader_definition200);
            if  (this->hasException())
            {
                goto rulepixel_shader_definitionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            ID4 =  this->matchToken(ID, &FOLLOW_ID_in_pixel_shader_definition202);
            if  (this->hasException())
            {
                goto rulepixel_shader_definitionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(16, &FOLLOW_16_in_pixel_shader_definition204);
            if  (this->hasException())
            {
                goto rulepixel_shader_definitionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(17, &FOLLOW_17_in_pixel_shader_definition206);
            if  (this->hasException())
            {
                goto rulepixel_shader_definitionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(21, &FOLLOW_21_in_pixel_shader_definition208);
            if  (this->hasException())
            {
                goto rulepixel_shader_definitionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            if ( this->get_backtracking()==0 )
            {
                 Listener->SetPixelShader( (ID4->getText()) ); 
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepixel_shader_definitionEx; /* Prevent compiler warnings */
    rulepixel_shader_definitionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end pixel_shader_definition */

/**
 * $ANTLR start type_definition
 * HLSL.g:64:1: type_definition : 'struct' ID LEFT_CURLY ( field_declaration )+ RIGHT_CURLY ';' ;
 */
void
HLSLParser::type_definition()
{
        HLSLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    const CommonTokenType*    ID5;

    /* Initialize rule variables
     */

    ID5       = NULL;


 
    {
        // HLSL.g:65:2: ( 'struct' ID LEFT_CURLY ( field_declaration )+ RIGHT_CURLY ';' )
        // HLSL.g:65:4: 'struct' ID LEFT_CURLY ( field_declaration )+ RIGHT_CURLY ';'
        {
             this->matchToken(42, &FOLLOW_42_in_type_definition218);
            if  (this->hasException())
            {
                goto ruletype_definitionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            ID5 =  this->matchToken(ID, &FOLLOW_ID_in_type_definition220);
            if  (this->hasException())
            {
                goto ruletype_definitionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_CURLY, &FOLLOW_LEFT_CURLY_in_type_definition222);
            if  (this->hasException())
            {
                goto ruletype_definitionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            if ( this->get_backtracking()==0 )
            {
                 Listener->StartTypeDefinition( (ID5->getText()) ); 
            }


            // HLSL.g:65:74: ( field_declaration )+
            {
                int cnt5=0;

                for (;;)
                {
                    int alt5=2;
            	switch ( this->LA(1) )
            	{
            	case ID:
            	case 32:
            	case 33:
            	case 34:
            	case 35:
            	case 36:
            	case 37:
            		{
            			alt5=1;
            		}
            	    break;

            	}

            	switch (alt5)
            	{
            	    case 1:
            	        // HLSL.g:65:74: field_declaration
            	        {
            	            this->followPush(FOLLOW_field_declaration_in_type_definition226);
            	            field_declaration();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto ruletype_definitionEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt5 >= 1 )
            		{
            		    goto loop5;
            		}
            		if (this->get_backtracking()>0)
            		{
            		    this->set_failedflag( true );
            		    return ;
            		}

            		/* mismatchedSetEx()
            		 */
            		new ANTLR_Exception< HLSLParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


            		goto ruletype_definitionEx;
            	}
            	cnt5++;
                }
                loop5: ;	/* Jump to here if this rule does not match */
            }

             this->matchToken(RIGHT_CURLY, &FOLLOW_RIGHT_CURLY_in_type_definition229);
            if  (this->hasException())
            {
                goto ruletype_definitionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(21, &FOLLOW_21_in_type_definition231);
            if  (this->hasException())
            {
                goto ruletype_definitionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            if ( this->get_backtracking()==0 )
            {
                 Listener->EndTypeDefinition(); 
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletype_definitionEx; /* Prevent compiler warnings */
    ruletype_definitionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end type_definition */

/**
 * $ANTLR start variable_declaration
 * HLSL.g:68:1: variable_declaration : ( type ID ';' | texture_type ID ';' | sampler );
 */
void
HLSLParser::variable_declaration()
{
        HLSLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    const CommonTokenType*    ID7;
    HLSLParser_texture_type_return texture_type6;
    typedef	HLSLParser_texture_type_return RETURN_TYPE_texture_type6;

    /* Initialize rule variables
     */

    ID7       = NULL;


 
    {
        {
            //  HLSL.g:69:2: ( type ID ';' | texture_type ID ';' | sampler )

            ANTLR_UINT32 alt6;

            alt6=3;

            switch ( this->LA(1) )
            {
            case ID:
            case 32:
            case 33:
            case 34:
            case 35:
            case 36:
            case 37:
            	{
            		alt6=1;
            	}
                break;
            case 29:
            	{
            		alt6=2;
            	}
                break;
            case 41:
            	{
            		alt6=3;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< HLSLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 6 );
                ex->set_state( 0 );


                goto rulevariable_declarationEx;

            }

            switch (alt6)
            {
        	case 1:
        	    // HLSL.g:69:4: type ID ';'
        	    {
        	        this->followPush(FOLLOW_type_in_variable_declaration245);
        	        type();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulevariable_declarationEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(ID, &FOLLOW_ID_in_variable_declaration247);
        	        if  (this->hasException())
        	        {
        	            goto rulevariable_declarationEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(21, &FOLLOW_21_in_variable_declaration249);
        	        if  (this->hasException())
        	        {
        	            goto rulevariable_declarationEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // HLSL.g:70:5: texture_type ID ';'
        	    {
        	        this->followPush(FOLLOW_texture_type_in_variable_declaration255);
        	        texture_type6=texture_type();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulevariable_declarationEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        ID7 =  this->matchToken(ID, &FOLLOW_ID_in_variable_declaration257);
        	        if  (this->hasException())
        	        {
        	            goto rulevariable_declarationEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(21, &FOLLOW_21_in_variable_declaration259);
        	        if  (this->hasException())
        	        {
        	            goto rulevariable_declarationEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        if ( this->get_backtracking()==0 )
        	        {
        	             std::cout << (this->get_strstream()->toStringTT(texture_type6.start, texture_type6.stop))
        	             << " \"" << (ID7->getText()) << "\";" << std::endl; 
        	        }


        	    }
        	    break;
        	case 3:
        	    // HLSL.g:71:4: sampler
        	    {
        	        this->followPush(FOLLOW_sampler_in_variable_declaration266);
        	        sampler();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulevariable_declarationEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulevariable_declarationEx; /* Prevent compiler warnings */
    rulevariable_declarationEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end variable_declaration */

/**
 * $ANTLR start sampler
 * HLSL.g:73:1: sampler : sampler_type ID LEFT_CURLY ( sampler_parameter )* RIGHT_CURLY ';' ;
 */
void
HLSLParser::sampler()
{
        HLSLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // HLSL.g:74:2: ( sampler_type ID LEFT_CURLY ( sampler_parameter )* RIGHT_CURLY ';' )
        // HLSL.g:74:4: sampler_type ID LEFT_CURLY ( sampler_parameter )* RIGHT_CURLY ';'
        {
            this->followPush(FOLLOW_sampler_type_in_sampler277);
            sampler_type();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesamplerEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(ID, &FOLLOW_ID_in_sampler279);
            if  (this->hasException())
            {
                goto rulesamplerEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_CURLY, &FOLLOW_LEFT_CURLY_in_sampler281);
            if  (this->hasException())
            {
                goto rulesamplerEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // HLSL.g:74:31: ( sampler_parameter )*

            for (;;)
            {
                int alt7=2;
                switch ( this->LA(1) )
                {
                case ID:
                case 29:
                	{
                		alt7=1;
                	}
                    break;

                }

                switch (alt7)
                {
            	case 1:
            	    // HLSL.g:74:31: sampler_parameter
            	    {
            	        this->followPush(FOLLOW_sampler_parameter_in_sampler283);
            	        sampler_parameter();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesamplerEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop7;	/* break out of the loop */
            	    break;
                }
            }
            loop7: ; /* Jump out to here if this rule does not match */


             this->matchToken(RIGHT_CURLY, &FOLLOW_RIGHT_CURLY_in_sampler286);
            if  (this->hasException())
            {
                goto rulesamplerEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(21, &FOLLOW_21_in_sampler288);
            if  (this->hasException())
            {
                goto rulesamplerEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesamplerEx; /* Prevent compiler warnings */
    rulesamplerEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end sampler */

/**
 * $ANTLR start sampler_type
 * HLSL.g:77:1: sampler_type : 'sampler2D' ;
 */
void
HLSLParser::sampler_type()
{
        HLSLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // HLSL.g:78:2: ( 'sampler2D' )
        // HLSL.g:78:4: 'sampler2D'
        {
             this->matchToken(41, &FOLLOW_41_in_sampler_type301);
            if  (this->hasException())
            {
                goto rulesampler_typeEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesampler_typeEx; /* Prevent compiler warnings */
    rulesampler_typeEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end sampler_type */

/**
 * $ANTLR start sampler_parameter
 * HLSL.g:81:1: sampler_parameter : ( 'Texture' '=' '<' ID '>' ';' | ID '=' ID ';' );
 */
void
HLSLParser::sampler_parameter()
{
        HLSLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  HLSL.g:82:2: ( 'Texture' '=' '<' ID '>' ';' | ID '=' ID ';' )

            ANTLR_UINT32 alt8;

            alt8=2;

            switch ( this->LA(1) )
            {
            case 29:
            	{
            		alt8=1;
            	}
                break;
            case ID:
            	{
            		alt8=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< HLSLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 8 );
                ex->set_state( 0 );


                goto rulesampler_parameterEx;

            }

            switch (alt8)
            {
        	case 1:
        	    // HLSL.g:82:4: 'Texture' '=' '<' ID '>' ';'
        	    {
        	         this->matchToken(29, &FOLLOW_29_in_sampler_parameter313);
        	        if  (this->hasException())
        	        {
        	            goto rulesampler_parameterEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(23, &FOLLOW_23_in_sampler_parameter315);
        	        if  (this->hasException())
        	        {
        	            goto rulesampler_parameterEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(22, &FOLLOW_22_in_sampler_parameter317);
        	        if  (this->hasException())
        	        {
        	            goto rulesampler_parameterEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(ID, &FOLLOW_ID_in_sampler_parameter319);
        	        if  (this->hasException())
        	        {
        	            goto rulesampler_parameterEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(24, &FOLLOW_24_in_sampler_parameter321);
        	        if  (this->hasException())
        	        {
        	            goto rulesampler_parameterEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(21, &FOLLOW_21_in_sampler_parameter323);
        	        if  (this->hasException())
        	        {
        	            goto rulesampler_parameterEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // HLSL.g:83:4: ID '=' ID ';'
        	    {
        	         this->matchToken(ID, &FOLLOW_ID_in_sampler_parameter328);
        	        if  (this->hasException())
        	        {
        	            goto rulesampler_parameterEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(23, &FOLLOW_23_in_sampler_parameter330);
        	        if  (this->hasException())
        	        {
        	            goto rulesampler_parameterEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(ID, &FOLLOW_ID_in_sampler_parameter332);
        	        if  (this->hasException())
        	        {
        	            goto rulesampler_parameterEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(21, &FOLLOW_21_in_sampler_parameter334);
        	        if  (this->hasException())
        	        {
        	            goto rulesampler_parameterEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulesampler_parameterEx; /* Prevent compiler warnings */
    rulesampler_parameterEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end sampler_parameter */

/**
 * $ANTLR start number_type
 * HLSL.g:85:1: number_type : ( 'float' | 'float2' | 'float3' | 'float4' | 'float1x1' | 'float1x2' );
 */
void
HLSLParser::number_type()
{
        HLSLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // HLSL.g:86:2: ( 'float' | 'float2' | 'float3' | 'float4' | 'float1x1' | 'float1x2' )
        // HLSL.g:
        {
            if ( ((this->LA(1) >= 32) && (this->LA(1) <= 37)) )
            {
                this->consume();
                this->set_perror_recovery(false);
                 this->set_failedflag(false); 

            }
            else
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                new ANTLR_Exception< HLSLParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
                this->get_exception()->set_expectingSet(NULL);

                goto rulenumber_typeEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenumber_typeEx; /* Prevent compiler warnings */
    rulenumber_typeEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end number_type */

/**
 * $ANTLR start texture_type
 * HLSL.g:94:1: texture_type : 'Texture' ;
 */
HLSLParser_texture_type_return
HLSLParser::texture_type()
{
    HLSLParser_texture_type_return retval(this);


    /* Initialize rule variables
     */

    retval.call_start_placeholder(); 



 
    {
        // HLSL.g:95:2: ( 'Texture' )
        // HLSL.g:95:4: 'Texture'
        {
             this->matchToken(29, &FOLLOW_29_in_texture_type383);
            if  (this->hasException())
            {
                goto ruletexture_typeEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletexture_typeEx; /* Prevent compiler warnings */
    ruletexture_typeEx: ;
    retval.call_stop_placeholder();



    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return retval;
}
/* $ANTLR end texture_type */

/**
 * $ANTLR start type
 * HLSL.g:98:1: type : ( number_type | ID );
 */
HLSLParser_type_return
HLSLParser::type()
{
    HLSLParser_type_return retval(this);


    /* Initialize rule variables
     */

    retval.call_start_placeholder(); 



 
    {
        {
            //  HLSL.g:98:6: ( number_type | ID )

            ANTLR_UINT32 alt9;

            alt9=2;

            switch ( this->LA(1) )
            {
            case 32:
            case 33:
            case 34:
            case 35:
            case 36:
            case 37:
            	{
            		alt9=1;
            	}
                break;
            case ID:
            	{
            		alt9=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< HLSLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 9 );
                ex->set_state( 0 );


                goto ruletypeEx;

            }

            switch (alt9)
            {
        	case 1:
        	    // HLSL.g:98:8: number_type
        	    {
        	        this->followPush(FOLLOW_number_type_in_type393);
        	        number_type();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletypeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }


        	    }
        	    break;
        	case 2:
        	    // HLSL.g:99:4: ID
        	    {
        	         this->matchToken(ID, &FOLLOW_ID_in_type398);
        	        if  (this->hasException())
        	        {
        	            goto ruletypeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruletypeEx; /* Prevent compiler warnings */
    ruletypeEx: ;
    retval.call_stop_placeholder();



    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return retval;
}
/* $ANTLR end type */

/**
 * $ANTLR start field_declaration
 * HLSL.g:102:1: field_declaration : type ID ':' semantic ';' ;
 */
void
HLSLParser::field_declaration()
{
        HLSLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    const CommonTokenType*    ID9;
    HLSLParser_type_return type8;
    typedef	HLSLParser_type_return RETURN_TYPE_type8;

    HLSLParser_semantic_return semantic10;
    typedef	HLSLParser_semantic_return RETURN_TYPE_semantic10;

    /* Initialize rule variables
     */

    ID9       = NULL;


 
    {
        // HLSL.g:103:2: ( type ID ':' semantic ';' )
        // HLSL.g:103:5: type ID ':' semantic ';'
        {
            this->followPush(FOLLOW_type_in_field_declaration411);
            type8=type();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefield_declarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            ID9 =  this->matchToken(ID, &FOLLOW_ID_in_field_declaration413);
            if  (this->hasException())
            {
                goto rulefield_declarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(20, &FOLLOW_20_in_field_declaration415);
            if  (this->hasException())
            {
                goto rulefield_declarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_semantic_in_field_declaration417);
            semantic10=semantic();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefield_declarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(21, &FOLLOW_21_in_field_declaration419);
            if  (this->hasException())
            {
                goto rulefield_declarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            if ( this->get_backtracking()==0 )
            {
                 Listener->AddField( (this->get_strstream()->toStringTT(type8.start, type8.stop))
                , (ID9->getText()), 
                (this->get_strstream()->toStringTT(semantic10.start, semantic10.stop))
                 ); 
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefield_declarationEx; /* Prevent compiler warnings */
    rulefield_declarationEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end field_declaration */

/**
 * $ANTLR start semantic
 * HLSL.g:106:1: semantic : ( 'POSITION' | 'TEXCOORD0' | 'COLOR0' );
 */
HLSLParser_semantic_return
HLSLParser::semantic()
{
    HLSLParser_semantic_return retval(this);


    /* Initialize rule variables
     */

    retval.call_start_placeholder(); 



 
    {
        // HLSL.g:107:2: ( 'POSITION' | 'TEXCOORD0' | 'COLOR0' )
        // HLSL.g:
        {
            if ( ((this->LA(1) >= 25) && (this->LA(1) <= 26)) || this->LA(1) == 28 )
            {
                this->consume();
                this->set_perror_recovery(false);
                 this->set_failedflag(false); 

            }
            else
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                new ANTLR_Exception< HLSLParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
                this->get_exception()->set_expectingSet(NULL);

                goto rulesemanticEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesemanticEx; /* Prevent compiler warnings */
    rulesemanticEx: ;
    retval.call_stop_placeholder();



    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return retval;
}
/* $ANTLR end semantic */

/**
 * $ANTLR start function
 * HLSL.g:112:1: function : type ID '(' (first= parameter_declaration ( ',' other= parameter_declaration )* )? ')' ( ':' semantic )? '{' ( statement )* '}' ;
 */
void
HLSLParser::function()
{
        HLSLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    const CommonTokenType*    ID12;
    Parameter first;
    typedef	Parameter RETURN_TYPE_first;

    Parameter other;
    typedef	Parameter RETURN_TYPE_other;

    HLSLParser_type_return type11;
    typedef	HLSLParser_type_return RETURN_TYPE_type11;

    HLSLParser_semantic_return semantic13;
    typedef	HLSLParser_semantic_return RETURN_TYPE_semantic13;

    /* Initialize rule variables
     */

     std::vector<Parameter> parameter_table; 
    ID12       = NULL;


 
    {
        // HLSL.g:114:2: ( type ID '(' (first= parameter_declaration ( ',' other= parameter_declaration )* )? ')' ( ':' semantic )? '{' ( statement )* '}' )
        // HLSL.g:115:3: type ID '(' (first= parameter_declaration ( ',' other= parameter_declaration )* )? ')' ( ':' semantic )? '{' ( statement )* '}'
        {
            this->followPush(FOLLOW_type_in_function466);
            type11=type();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefunctionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            ID12 =  this->matchToken(ID, &FOLLOW_ID_in_function468);
            if  (this->hasException())
            {
                goto rulefunctionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(16, &FOLLOW_16_in_function470);
            if  (this->hasException())
            {
                goto rulefunctionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // HLSL.g:116:4: (first= parameter_declaration ( ',' other= parameter_declaration )* )?
            {
                int alt11=2;
                switch ( this->LA(1) )
                {
                    case ID:
                    case 32:
                    case 33:
                    case 34:
                    case 35:
                    case 36:
                    case 37:
                    	{
                    		alt11=1;
                    	}
                        break;
                }

                switch (alt11)
                {
            	case 1:
            	    // HLSL.g:116:6: first= parameter_declaration ( ',' other= parameter_declaration )*
            	    {
            	        this->followPush(FOLLOW_parameter_declaration_in_function482);
            	        first=parameter_declaration();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunctionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        if ( this->get_backtracking()==0 )
            	        {
            	             parameter_table.push_back( first
            	             ); 
            	        }


            	        // HLSL.g:117:4: ( ',' other= parameter_declaration )*

            	        for (;;)
            	        {
            	            int alt10=2;
            	            switch ( this->LA(1) )
            	            {
            	            case 18:
            	            	{
            	            		alt10=1;
            	            	}
            	                break;

            	            }

            	            switch (alt10)
            	            {
            	        	case 1:
            	        	    // HLSL.g:117:6: ',' other= parameter_declaration
            	        	    {
            	        	         this->matchToken(18, &FOLLOW_18_in_function491);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefunctionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_parameter_declaration_in_function497);
            	        	        other=parameter_declaration();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefunctionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        if ( this->get_backtracking()==0 )
            	        	        {
            	        	             parameter_table.push_back( other
            	        	             ); 
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop10;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop10: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

             this->matchToken(17, &FOLLOW_17_in_function511);
            if  (this->hasException())
            {
                goto rulefunctionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // HLSL.g:118:8: ( ':' semantic )?
            {
                int alt12=2;
                switch ( this->LA(1) )
                {
                    case 20:
                    	{
                    		alt12=1;
                    	}
                        break;
                }

                switch (alt12)
                {
            	case 1:
            	    // HLSL.g:118:10: ':' semantic
            	    {
            	         this->matchToken(20, &FOLLOW_20_in_function515);
            	        if  (this->hasException())
            	        {
            	            goto rulefunctionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_semantic_in_function517);
            	        semantic13=semantic();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunctionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(LEFT_CURLY, &FOLLOW_LEFT_CURLY_in_function522);
            if  (this->hasException())
            {
                goto rulefunctionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            if ( this->get_backtracking()==0 )
            {
                 Listener->StartFunction( (this->get_strstream()->toStringTT(type11.start, type11.stop))
                , (ID12->getText()), parameter_table, 
                (this->get_strstream()->toStringTT(semantic13.start, semantic13.stop))
                 ); 
            }


            // HLSL.g:120:4: ( statement )*

            for (;;)
            {
                int alt13=2;
                switch ( this->LA(1) )
                {
                case FLOAT:
                case ID:
                case INT:
                case 29:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                case 37:
                case 40:
                case 41:
                	{
                		alt13=1;
                	}
                    break;

                }

                switch (alt13)
                {
            	case 1:
            	    // HLSL.g:120:4: statement
            	    {
            	        this->followPush(FOLLOW_statement_in_function533);
            	        statement();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunctionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop13;	/* break out of the loop */
            	    break;
                }
            }
            loop13: ; /* Jump out to here if this rule does not match */


            if ( this->get_backtracking()==0 )
            {
                 Listener->EndFunction(); 
            }


             this->matchToken(RIGHT_CURLY, &FOLLOW_RIGHT_CURLY_in_function549);
            if  (this->hasException())
            {
                goto rulefunctionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefunctionEx; /* Prevent compiler warnings */
    rulefunctionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end function */

/**
 * $ANTLR start parameter_declaration
 * HLSL.g:125:1: parameter_declaration returns [ Parameter parameter ] : type ID ( ':' semantic )? ;
 */
Parameter
HLSLParser::parameter_declaration()
{
        HLSLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    Parameter parameter;


    const CommonTokenType*    ID15;
    HLSLParser_type_return type14;
    typedef	HLSLParser_type_return RETURN_TYPE_type14;

    HLSLParser_semantic_return semantic16;
    typedef	HLSLParser_semantic_return RETURN_TYPE_semantic16;

    /* Initialize rule variables
     */

    ID15       = NULL;


 
    {
        // HLSL.g:126:2: ( type ID ( ':' semantic )? )
        // HLSL.g:126:4: type ID ( ':' semantic )?
        {
            this->followPush(FOLLOW_type_in_parameter_declaration563);
            type14=type();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleparameter_declarationEx;
            }
            if (this->hasFailed())
            {
                return parameter;
            }


            ID15 =  this->matchToken(ID, &FOLLOW_ID_in_parameter_declaration565);
            if  (this->hasException())
            {
                goto ruleparameter_declarationEx;
            }
            if (this->hasFailed())
            {
                return parameter;
            }


            if ( this->get_backtracking()==0 )
            {
                parameter.Type = (this->get_strstream()->toStringTT(type14.start, type14.stop))
                ; parameter.Name = (ID15->getText());
            }


            // HLSL.g:126:70: ( ':' semantic )?
            {
                int alt14=2;
                switch ( this->LA(1) )
                {
                    case 20:
                    	{
                    		alt14=1;
                    	}
                        break;
                }

                switch (alt14)
                {
            	case 1:
            	    // HLSL.g:126:72: ':' semantic
            	    {
            	         this->matchToken(20, &FOLLOW_20_in_parameter_declaration571);
            	        if  (this->hasException())
            	        {
            	            goto ruleparameter_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return parameter;
            	        }


            	        this->followPush(FOLLOW_semantic_in_parameter_declaration573);
            	        semantic16=semantic();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleparameter_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return parameter;
            	        }


            	        if ( this->get_backtracking()==0 )
            	        {
            	             parameter.Semantic = (this->get_strstream()->toStringTT(semantic16.start, semantic16.stop))
            	            ; 
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleparameter_declarationEx; /* Prevent compiler warnings */
    ruleparameter_declarationEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return parameter;
}
/* $ANTLR end parameter_declaration */

/**
 * $ANTLR start statement
 * HLSL.g:129:1: statement : ( variable_declaration | 'return' exp ';' | exp ';' );
 */
void
HLSLParser::statement()
{
        HLSLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    HLSLParser_exp_return exp17;
    typedef	HLSLParser_exp_return RETURN_TYPE_exp17;

    /* Initialize rule variables
     */


 
    {
        {
            //  HLSL.g:130:2: ( variable_declaration | 'return' exp ';' | exp ';' )

            ANTLR_UINT32 alt15;

            alt15=3;

            switch ( this->LA(1) )
            {
            case 32:
            case 33:
            case 34:
            case 35:
            case 36:
            case 37:
            	{
            		switch ( this->LA(2) )
            		{
            		case ID:
            			{
            				alt15=1;
            			}
            		    break;
            		case 16:
            			{
            				alt15=3;
            			}
            		    break;

            		default:
            		    if (this->get_backtracking()>0)
            		    {
            		        this->set_failedflag( true );
            		        return ;
            		    }

            		    ExceptionBaseType* ex = new ANTLR_Exception< HLSLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 15 );
            		    ex->set_state( 1 );


            		    goto rulestatementEx;

            		}

            	}
                break;
            case ID:
            	{
            		switch ( this->LA(2) )
            		{
            		case 16:
            		case 19:
            		case 21:
            		case 23:
            			{
            				alt15=3;
            			}
            		    break;
            		case ID:
            			{
            				alt15=1;
            			}
            		    break;

            		default:
            		    if (this->get_backtracking()>0)
            		    {
            		        this->set_failedflag( true );
            		        return ;
            		    }

            		    ExceptionBaseType* ex = new ANTLR_Exception< HLSLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 15 );
            		    ex->set_state( 2 );


            		    goto rulestatementEx;

            		}

            	}
                break;
            case 29:
            case 41:
            	{
            		alt15=1;
            	}
                break;
            case 40:
            	{
            		alt15=2;
            	}
                break;
            case FLOAT:
            case INT:
            	{
            		alt15=3;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< HLSLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 15 );
                ex->set_state( 0 );


                goto rulestatementEx;

            }

            switch (alt15)
            {
        	case 1:
        	    // HLSL.g:130:4: variable_declaration
        	    {
        	        this->followPush(FOLLOW_variable_declaration_in_statement589);
        	        variable_declaration();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // HLSL.g:131:4: 'return' exp ';'
        	    {
        	         this->matchToken(40, &FOLLOW_40_in_statement594);
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_exp_in_statement596);
        	        exp17=exp();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(21, &FOLLOW_21_in_statement598);
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        if ( this->get_backtracking()==0 )
        	        {
        	             Listener->ProcessReturnStatement( (this->get_strstream()->toStringTT(exp17.start, exp17.stop))
        	             ); 
        	        }


        	    }
        	    break;
        	case 3:
        	    // HLSL.g:132:4: exp ';'
        	    {
        	        this->followPush(FOLLOW_exp_in_statement605);
        	        exp();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(21, &FOLLOW_21_in_statement607);
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulestatementEx; /* Prevent compiler warnings */
    rulestatementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end statement */

/**
 * $ANTLR start exp
 * HLSL.g:134:1: exp : ( function_call | variable ( '=' exp )? | constructor | number );
 */
HLSLParser_exp_return
HLSLParser::exp()
{
    HLSLParser_exp_return retval(this);


    /* Initialize rule variables
     */

    retval.call_start_placeholder(); 



 
    {
        {
            //  HLSL.g:134:5: ( function_call | variable ( '=' exp )? | constructor | number )

            ANTLR_UINT32 alt17;

            alt17=4;

            switch ( this->LA(1) )
            {
            case ID:
            	{
            		switch ( this->LA(2) )
            		{
            		case 16:
            			{
            				alt17=1;
            			}
            		    break;
            		case EOF:
            		case 17:
            		case 18:
            		case 19:
            		case 21:
            		case 23:
            			{
            				alt17=2;
            			}
            		    break;

            		default:
            		    if (this->get_backtracking()>0)
            		    {
            		        this->set_failedflag( true );
            		        return retval;
            		    }

            		    ExceptionBaseType* ex = new ANTLR_Exception< HLSLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 17 );
            		    ex->set_state( 1 );


            		    goto ruleexpEx;

            		}

            	}
                break;
            case 32:
            case 33:
            case 34:
            case 35:
            case 36:
            case 37:
            	{
            		alt17=3;
            	}
                break;
            case FLOAT:
            case INT:
            	{
            		alt17=4;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retval;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< HLSLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 17 );
                ex->set_state( 0 );


                goto ruleexpEx;

            }

            switch (alt17)
            {
        	case 1:
        	    // HLSL.g:135:2: function_call
        	    {
        	        this->followPush(FOLLOW_function_call_in_exp617);
        	        function_call();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleexpEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }


        	    }
        	    break;
        	case 2:
        	    // HLSL.g:136:4: variable ( '=' exp )?
        	    {
        	        this->followPush(FOLLOW_variable_in_exp622);
        	        variable();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleexpEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }


        	        // HLSL.g:136:13: ( '=' exp )?
        	        {
        	            int alt16=2;
        	            switch ( this->LA(1) )
        	            {
        	                case 23:
        	                	{
        	                		alt16=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt16)
        	            {
        	        	case 1:
        	        	    // HLSL.g:136:14: '=' exp
        	        	    {
        	        	         this->matchToken(23, &FOLLOW_23_in_exp625);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleexpEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }


        	        	        this->followPush(FOLLOW_exp_in_exp627);
        	        	        exp();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleexpEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return retval;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 3:
        	    // HLSL.g:137:4: constructor
        	    {
        	        this->followPush(FOLLOW_constructor_in_exp634);
        	        constructor();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleexpEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }


        	    }
        	    break;
        	case 4:
        	    // HLSL.g:138:4: number
        	    {
        	        this->followPush(FOLLOW_number_in_exp639);
        	        number();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleexpEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retval;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleexpEx; /* Prevent compiler warnings */
    ruleexpEx: ;
    retval.call_stop_placeholder();



    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return retval;
}
/* $ANTLR end exp */

/**
 * $ANTLR start variable
 * HLSL.g:141:1: variable : ( ID '.' variable | ID );
 */
void
HLSLParser::variable()
{
        HLSLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  HLSL.g:142:2: ( ID '.' variable | ID )

            ANTLR_UINT32 alt18;

            alt18=2;

            switch ( this->LA(1) )
            {
            case ID:
            	{
            		switch ( this->LA(2) )
            		{
            		case 19:
            			{
            				alt18=1;
            			}
            		    break;
            		case EOF:
            		case 17:
            		case 18:
            		case 21:
            		case 23:
            			{
            				alt18=2;
            			}
            		    break;

            		default:
            		    if (this->get_backtracking()>0)
            		    {
            		        this->set_failedflag( true );
            		        return ;
            		    }

            		    ExceptionBaseType* ex = new ANTLR_Exception< HLSLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 18 );
            		    ex->set_state( 1 );


            		    goto rulevariableEx;

            		}

            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< HLSLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 18 );
                ex->set_state( 0 );


                goto rulevariableEx;

            }

            switch (alt18)
            {
        	case 1:
        	    // HLSL.g:142:4: ID '.' variable
        	    {
        	         this->matchToken(ID, &FOLLOW_ID_in_variable652);
        	        if  (this->hasException())
        	        {
        	            goto rulevariableEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(19, &FOLLOW_19_in_variable654);
        	        if  (this->hasException())
        	        {
        	            goto rulevariableEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_variable_in_variable656);
        	        variable();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulevariableEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // HLSL.g:143:4: ID
        	    {
        	         this->matchToken(ID, &FOLLOW_ID_in_variable661);
        	        if  (this->hasException())
        	        {
        	            goto rulevariableEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulevariableEx; /* Prevent compiler warnings */
    rulevariableEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end variable */

/**
 * $ANTLR start function_call
 * HLSL.g:145:1: function_call : ID '(' ( exp ( ',' exp )* )? ')' ;
 */
void
HLSLParser::function_call()
{
        HLSLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // HLSL.g:146:2: ( ID '(' ( exp ( ',' exp )* )? ')' )
        // HLSL.g:146:4: ID '(' ( exp ( ',' exp )* )? ')'
        {
             this->matchToken(ID, &FOLLOW_ID_in_function_call671);
            if  (this->hasException())
            {
                goto rulefunction_callEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(16, &FOLLOW_16_in_function_call673);
            if  (this->hasException())
            {
                goto rulefunction_callEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // HLSL.g:146:11: ( exp ( ',' exp )* )?
            {
                int alt20=2;
                switch ( this->LA(1) )
                {
                    case FLOAT:
                    case ID:
                    case INT:
                    case 32:
                    case 33:
                    case 34:
                    case 35:
                    case 36:
                    case 37:
                    	{
                    		alt20=1;
                    	}
                        break;
                }

                switch (alt20)
                {
            	case 1:
            	    // HLSL.g:146:13: exp ( ',' exp )*
            	    {
            	        this->followPush(FOLLOW_exp_in_function_call677);
            	        exp();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_callEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // HLSL.g:146:17: ( ',' exp )*

            	        for (;;)
            	        {
            	            int alt19=2;
            	            switch ( this->LA(1) )
            	            {
            	            case 18:
            	            	{
            	            		alt19=1;
            	            	}
            	                break;

            	            }

            	            switch (alt19)
            	            {
            	        	case 1:
            	        	    // HLSL.g:146:19: ',' exp
            	        	    {
            	        	         this->matchToken(18, &FOLLOW_18_in_function_call681);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefunction_callEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_exp_in_function_call683);
            	        	        exp();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefunction_callEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop19;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop19: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

             this->matchToken(17, &FOLLOW_17_in_function_call691);
            if  (this->hasException())
            {
                goto rulefunction_callEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefunction_callEx; /* Prevent compiler warnings */
    rulefunction_callEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end function_call */

/**
 * $ANTLR start constructor
 * HLSL.g:149:1: constructor : number_type '(' exp ( ',' exp )* ')' ;
 */
void
HLSLParser::constructor()
{
        HLSLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // HLSL.g:150:2: ( number_type '(' exp ( ',' exp )* ')' )
        // HLSL.g:150:4: number_type '(' exp ( ',' exp )* ')'
        {
            this->followPush(FOLLOW_number_type_in_constructor704);
            number_type();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleconstructorEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(16, &FOLLOW_16_in_constructor706);
            if  (this->hasException())
            {
                goto ruleconstructorEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_exp_in_constructor708);
            exp();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleconstructorEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // HLSL.g:150:25: ( ',' exp )*

            for (;;)
            {
                int alt21=2;
                switch ( this->LA(1) )
                {
                case 18:
                	{
                		alt21=1;
                	}
                    break;

                }

                switch (alt21)
                {
            	case 1:
            	    // HLSL.g:150:27: ',' exp
            	    {
            	         this->matchToken(18, &FOLLOW_18_in_constructor713);
            	        if  (this->hasException())
            	        {
            	            goto ruleconstructorEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_exp_in_constructor715);
            	        exp();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleconstructorEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop21;	/* break out of the loop */
            	    break;
                }
            }
            loop21: ; /* Jump out to here if this rule does not match */


             this->matchToken(17, &FOLLOW_17_in_constructor720);
            if  (this->hasException())
            {
                goto ruleconstructorEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleconstructorEx; /* Prevent compiler warnings */
    ruleconstructorEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end constructor */

/**
 * $ANTLR start number
 * HLSL.g:156:1: number : ( FLOAT | INT );
 */
void
HLSLParser::number()
{
        HLSLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // HLSL.g:157:2: ( FLOAT | INT )
        // HLSL.g:
        {
            if ( this->LA(1) == FLOAT || this->LA(1) == INT )
            {
                this->consume();
                this->set_perror_recovery(false);
                 this->set_failedflag(false); 

            }
            else
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                new ANTLR_Exception< HLSLParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
                this->get_exception()->set_expectingSet(NULL);

                goto rulenumberEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenumberEx; /* Prevent compiler warnings */
    rulenumberEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end number */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */



/* End of code
 * =============================================================================
 */
