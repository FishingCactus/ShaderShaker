/** \file
 *  This C++ source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : HLSL.g
 *     -                            On : 2012-06-13 15:50:08
 *     -                for the parser : HLSLParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy lifting from C Run-time by Jim Idle )
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram, ElectronDB
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "HLSLParser.hpp"
/* ----------------------------------------- */


/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

using namespace antlr3;
/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
ANTLR_UINT8*   HLSLParserTokenNames[41+4]
     = {
        (ANTLR_UINT8*) "<invalid>",       /* String to print to indicate an invalid token */
        (ANTLR_UINT8*) "<EOR>",
        (ANTLR_UINT8*) "<DOWN>",
        (ANTLR_UINT8*) "<UP>",
        (ANTLR_UINT8*) "COMMENT",
        (ANTLR_UINT8*) "ESC_SEQ",
        (ANTLR_UINT8*) "EXPONENT",
        (ANTLR_UINT8*) "FLOAT",
        (ANTLR_UINT8*) "HEX_DIGIT",
        (ANTLR_UINT8*) "ID",
        (ANTLR_UINT8*) "INT",
        (ANTLR_UINT8*) "LEFT_CURLY",
        (ANTLR_UINT8*) "OCTAL_ESC",
        (ANTLR_UINT8*) "RIGHT_CURLY",
        (ANTLR_UINT8*) "STRING",
        (ANTLR_UINT8*) "WS",
        (ANTLR_UINT8*) "'('",
        (ANTLR_UINT8*) "')'",
        (ANTLR_UINT8*) "','",
        (ANTLR_UINT8*) "'.'",
        (ANTLR_UINT8*) "':'",
        (ANTLR_UINT8*) "';'",
        (ANTLR_UINT8*) "'<'",
        (ANTLR_UINT8*) "'='",
        (ANTLR_UINT8*) "'>'",
        (ANTLR_UINT8*) "'COLOR0'",
        (ANTLR_UINT8*) "'POSITION'",
        (ANTLR_UINT8*) "'PixelShader'",
        (ANTLR_UINT8*) "'TEXCOORD0'",
        (ANTLR_UINT8*) "'Texture'",
        (ANTLR_UINT8*) "'VertexShader'",
        (ANTLR_UINT8*) "'compile'",
        (ANTLR_UINT8*) "'float'",
        (ANTLR_UINT8*) "'float1x1'",
        (ANTLR_UINT8*) "'float1x2'",
        (ANTLR_UINT8*) "'float2'",
        (ANTLR_UINT8*) "'float3'",
        (ANTLR_UINT8*) "'float4'",
        (ANTLR_UINT8*) "'pass'",
        (ANTLR_UINT8*) "'ps_3_0'",
        (ANTLR_UINT8*) "'return'",
        (ANTLR_UINT8*) "'sampler2D'",
        (ANTLR_UINT8*) "'struct'",
        (ANTLR_UINT8*) "'technique'",
        (ANTLR_UINT8*) "'vs_3_0'"
       };


/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "HLSL.g";

/** \brief Return the name of the grammar file that generated this code.
 */
const char* HLSLParser::getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new HLSLParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
HLSLParser::HLSLParser( StreamType* instream)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, NULL)

{
	// See if we can create a new parser with the standard constructor
	//
	this->init(instream);
}

/** \brief Create a new HLSLParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
HLSLParser::HLSLParser( StreamType* instream, RecognizerSharedStateType* state)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, state)

{
	this->init(instream );
}

void HLSLParser::init(StreamType* instream)
{
	/* Install the token table
	*/
	this->get_psrstate()->set_tokenNames( HLSLParserTokenNames );


}

void
HLSLParser::reset()
{
    this->get_rec()->reset();
}

/** Free the parser resources
 */
HLSLParser::~HLSLParser()
 {
}

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static ANTLR_UINT8**	getTokenNames()
{
        return HLSLParserTokenNames;
}

/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_global_declaration_in_translation_unit66_bits[]	= { ANTLR_UINT64_LIT(0x00000E3F20000202) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_global_declaration_in_translation_unit66( FOLLOW_global_declaration_in_translation_unit66_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_technique_in_translation_unit69_bits[]	= { ANTLR_UINT64_LIT(0x0000080000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_technique_in_translation_unit69( FOLLOW_technique_in_translation_unit69_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_type_definition_in_global_declaration82_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_type_definition_in_global_declaration82( FOLLOW_type_definition_in_global_declaration82_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_variable_declaration_in_global_declaration87_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_variable_declaration_in_global_declaration87( FOLLOW_variable_declaration_in_global_declaration87_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_function_in_global_declaration92_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_function_in_global_declaration92( FOLLOW_function_in_global_declaration92_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_43_in_technique104_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000200) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_43_in_technique104( FOLLOW_43_in_technique104_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_ID_in_technique106_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000800) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_ID_in_technique106( FOLLOW_ID_in_technique106_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_CURLY_in_technique108_bits[]	= { ANTLR_UINT64_LIT(0x0000004000002000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_LEFT_CURLY_in_technique108( FOLLOW_LEFT_CURLY_in_technique108_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_pass_in_technique114_bits[]	= { ANTLR_UINT64_LIT(0x0000004000002000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_pass_in_technique114( FOLLOW_pass_in_technique114_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_CURLY_in_technique119_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_RIGHT_CURLY_in_technique119( FOLLOW_RIGHT_CURLY_in_technique119_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_38_in_pass132_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000200) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_38_in_pass132( FOLLOW_38_in_pass132_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_ID_in_pass134_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000800) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_ID_in_pass134( FOLLOW_ID_in_pass134_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_CURLY_in_pass138_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_LEFT_CURLY_in_pass138( FOLLOW_LEFT_CURLY_in_pass138_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_vertex_shader_definition_in_pass140_bits[]	= { ANTLR_UINT64_LIT(0x0000000008000000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_vertex_shader_definition_in_pass140( FOLLOW_vertex_shader_definition_in_pass140_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_pixel_shader_definition_in_pass142_bits[]	= { ANTLR_UINT64_LIT(0x0000000000002000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_pixel_shader_definition_in_pass142( FOLLOW_pixel_shader_definition_in_pass142_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_CURLY_in_pass144_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_RIGHT_CURLY_in_pass144( FOLLOW_RIGHT_CURLY_in_pass144_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_30_in_vertex_shader_definition158_bits[]	= { ANTLR_UINT64_LIT(0x0000000000800000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_30_in_vertex_shader_definition158( FOLLOW_30_in_vertex_shader_definition158_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_23_in_vertex_shader_definition160_bits[]	= { ANTLR_UINT64_LIT(0x0000000080000000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_23_in_vertex_shader_definition160( FOLLOW_23_in_vertex_shader_definition160_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_31_in_vertex_shader_definition162_bits[]	= { ANTLR_UINT64_LIT(0x0000100000000000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_31_in_vertex_shader_definition162( FOLLOW_31_in_vertex_shader_definition162_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_44_in_vertex_shader_definition164_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000200) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_44_in_vertex_shader_definition164( FOLLOW_44_in_vertex_shader_definition164_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_ID_in_vertex_shader_definition166_bits[]	= { ANTLR_UINT64_LIT(0x0000000000010000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_ID_in_vertex_shader_definition166( FOLLOW_ID_in_vertex_shader_definition166_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_16_in_vertex_shader_definition168_bits[]	= { ANTLR_UINT64_LIT(0x0000000000020000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_16_in_vertex_shader_definition168( FOLLOW_16_in_vertex_shader_definition168_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_17_in_vertex_shader_definition170_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_17_in_vertex_shader_definition170( FOLLOW_17_in_vertex_shader_definition170_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_21_in_vertex_shader_definition172_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_21_in_vertex_shader_definition172( FOLLOW_21_in_vertex_shader_definition172_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_27_in_pixel_shader_definition196_bits[]	= { ANTLR_UINT64_LIT(0x0000000000800000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_27_in_pixel_shader_definition196( FOLLOW_27_in_pixel_shader_definition196_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_23_in_pixel_shader_definition198_bits[]	= { ANTLR_UINT64_LIT(0x0000000080000000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_23_in_pixel_shader_definition198( FOLLOW_23_in_pixel_shader_definition198_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_31_in_pixel_shader_definition200_bits[]	= { ANTLR_UINT64_LIT(0x0000008000000000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_31_in_pixel_shader_definition200( FOLLOW_31_in_pixel_shader_definition200_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_39_in_pixel_shader_definition202_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000200) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_39_in_pixel_shader_definition202( FOLLOW_39_in_pixel_shader_definition202_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_ID_in_pixel_shader_definition204_bits[]	= { ANTLR_UINT64_LIT(0x0000000000010000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_ID_in_pixel_shader_definition204( FOLLOW_ID_in_pixel_shader_definition204_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_16_in_pixel_shader_definition206_bits[]	= { ANTLR_UINT64_LIT(0x0000000000020000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_16_in_pixel_shader_definition206( FOLLOW_16_in_pixel_shader_definition206_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_17_in_pixel_shader_definition208_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_17_in_pixel_shader_definition208( FOLLOW_17_in_pixel_shader_definition208_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_21_in_pixel_shader_definition210_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_21_in_pixel_shader_definition210( FOLLOW_21_in_pixel_shader_definition210_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_42_in_type_definition220_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000200) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_42_in_type_definition220( FOLLOW_42_in_type_definition220_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_ID_in_type_definition222_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000800) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_ID_in_type_definition222( FOLLOW_ID_in_type_definition222_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_CURLY_in_type_definition224_bits[]	= { ANTLR_UINT64_LIT(0x0000003F00000200) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_LEFT_CURLY_in_type_definition224( FOLLOW_LEFT_CURLY_in_type_definition224_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_field_declaration_in_type_definition226_bits[]	= { ANTLR_UINT64_LIT(0x0000003F00002200) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_field_declaration_in_type_definition226( FOLLOW_field_declaration_in_type_definition226_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_CURLY_in_type_definition229_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_RIGHT_CURLY_in_type_definition229( FOLLOW_RIGHT_CURLY_in_type_definition229_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_21_in_type_definition231_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_21_in_type_definition231( FOLLOW_21_in_type_definition231_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_type_in_variable_declaration243_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000200) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_type_in_variable_declaration243( FOLLOW_type_in_variable_declaration243_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_ID_in_variable_declaration245_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_ID_in_variable_declaration245( FOLLOW_ID_in_variable_declaration245_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_21_in_variable_declaration247_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_21_in_variable_declaration247( FOLLOW_21_in_variable_declaration247_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_texture_type_in_variable_declaration253_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000200) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_texture_type_in_variable_declaration253( FOLLOW_texture_type_in_variable_declaration253_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_ID_in_variable_declaration255_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_ID_in_variable_declaration255( FOLLOW_ID_in_variable_declaration255_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_21_in_variable_declaration257_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_21_in_variable_declaration257( FOLLOW_21_in_variable_declaration257_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_sampler_in_variable_declaration264_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_sampler_in_variable_declaration264( FOLLOW_sampler_in_variable_declaration264_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_sampler_type_in_sampler275_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000200) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_sampler_type_in_sampler275( FOLLOW_sampler_type_in_sampler275_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_ID_in_sampler277_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000800) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_ID_in_sampler277( FOLLOW_ID_in_sampler277_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_CURLY_in_sampler279_bits[]	= { ANTLR_UINT64_LIT(0x0000000020002200) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_LEFT_CURLY_in_sampler279( FOLLOW_LEFT_CURLY_in_sampler279_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_sampler_parameter_in_sampler281_bits[]	= { ANTLR_UINT64_LIT(0x0000000020002200) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_sampler_parameter_in_sampler281( FOLLOW_sampler_parameter_in_sampler281_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_CURLY_in_sampler284_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_RIGHT_CURLY_in_sampler284( FOLLOW_RIGHT_CURLY_in_sampler284_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_21_in_sampler286_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_21_in_sampler286( FOLLOW_21_in_sampler286_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_41_in_sampler_type299_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_41_in_sampler_type299( FOLLOW_41_in_sampler_type299_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_29_in_sampler_parameter311_bits[]	= { ANTLR_UINT64_LIT(0x0000000000800000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_29_in_sampler_parameter311( FOLLOW_29_in_sampler_parameter311_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_23_in_sampler_parameter313_bits[]	= { ANTLR_UINT64_LIT(0x0000000000400000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_23_in_sampler_parameter313( FOLLOW_23_in_sampler_parameter313_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_22_in_sampler_parameter315_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000200) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_22_in_sampler_parameter315( FOLLOW_22_in_sampler_parameter315_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_ID_in_sampler_parameter317_bits[]	= { ANTLR_UINT64_LIT(0x0000000001000000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_ID_in_sampler_parameter317( FOLLOW_ID_in_sampler_parameter317_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_24_in_sampler_parameter319_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_24_in_sampler_parameter319( FOLLOW_24_in_sampler_parameter319_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_21_in_sampler_parameter321_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_21_in_sampler_parameter321( FOLLOW_21_in_sampler_parameter321_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_ID_in_sampler_parameter326_bits[]	= { ANTLR_UINT64_LIT(0x0000000000800000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_ID_in_sampler_parameter326( FOLLOW_ID_in_sampler_parameter326_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_23_in_sampler_parameter328_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000200) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_23_in_sampler_parameter328( FOLLOW_23_in_sampler_parameter328_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_ID_in_sampler_parameter330_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_ID_in_sampler_parameter330( FOLLOW_ID_in_sampler_parameter330_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_21_in_sampler_parameter332_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_21_in_sampler_parameter332( FOLLOW_21_in_sampler_parameter332_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_29_in_texture_type381_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_29_in_texture_type381( FOLLOW_29_in_texture_type381_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_number_type_in_type391_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_number_type_in_type391( FOLLOW_number_type_in_type391_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_ID_in_type396_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_ID_in_type396( FOLLOW_ID_in_type396_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_type_in_field_declaration409_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000200) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_type_in_field_declaration409( FOLLOW_type_in_field_declaration409_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_ID_in_field_declaration411_bits[]	= { ANTLR_UINT64_LIT(0x0000000000100000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_ID_in_field_declaration411( FOLLOW_ID_in_field_declaration411_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_20_in_field_declaration413_bits[]	= { ANTLR_UINT64_LIT(0x0000000016000000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_20_in_field_declaration413( FOLLOW_20_in_field_declaration413_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_semantic_in_field_declaration415_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_semantic_in_field_declaration415( FOLLOW_semantic_in_field_declaration415_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_21_in_field_declaration417_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_21_in_field_declaration417( FOLLOW_21_in_field_declaration417_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_type_in_function454_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000200) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_type_in_function454( FOLLOW_type_in_function454_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_ID_in_function456_bits[]	= { ANTLR_UINT64_LIT(0x0000000000010000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_ID_in_function456( FOLLOW_ID_in_function456_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_16_in_function458_bits[]	= { ANTLR_UINT64_LIT(0x0000003F00020200) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_16_in_function458( FOLLOW_16_in_function458_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_parameter_declaration_in_function462_bits[]	= { ANTLR_UINT64_LIT(0x0000000000060000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_parameter_declaration_in_function462( FOLLOW_parameter_declaration_in_function462_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_18_in_function466_bits[]	= { ANTLR_UINT64_LIT(0x0000003F00000200) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_18_in_function466( FOLLOW_18_in_function466_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_parameter_declaration_in_function468_bits[]	= { ANTLR_UINT64_LIT(0x0000000000060000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_parameter_declaration_in_function468( FOLLOW_parameter_declaration_in_function468_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_17_in_function476_bits[]	= { ANTLR_UINT64_LIT(0x0000000000100800) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_17_in_function476( FOLLOW_17_in_function476_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_20_in_function480_bits[]	= { ANTLR_UINT64_LIT(0x0000000016000000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_20_in_function480( FOLLOW_20_in_function480_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_semantic_in_function482_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000800) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_semantic_in_function482( FOLLOW_semantic_in_function482_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_CURLY_in_function487_bits[]	= { ANTLR_UINT64_LIT(0x0000033F20002680) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_LEFT_CURLY_in_function487( FOLLOW_LEFT_CURLY_in_function487_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_statement_in_function489_bits[]	= { ANTLR_UINT64_LIT(0x0000033F20002680) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_statement_in_function489( FOLLOW_statement_in_function489_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_CURLY_in_function492_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_RIGHT_CURLY_in_function492( FOLLOW_RIGHT_CURLY_in_function492_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_type_in_parameter_declaration502_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000200) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_type_in_parameter_declaration502( FOLLOW_type_in_parameter_declaration502_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_ID_in_parameter_declaration504_bits[]	= { ANTLR_UINT64_LIT(0x0000000000100002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_ID_in_parameter_declaration504( FOLLOW_ID_in_parameter_declaration504_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_20_in_parameter_declaration508_bits[]	= { ANTLR_UINT64_LIT(0x0000000016000000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_20_in_parameter_declaration508( FOLLOW_20_in_parameter_declaration508_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_semantic_in_parameter_declaration510_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_semantic_in_parameter_declaration510( FOLLOW_semantic_in_parameter_declaration510_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_variable_declaration_in_statement524_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_variable_declaration_in_statement524( FOLLOW_variable_declaration_in_statement524_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_40_in_statement529_bits[]	= { ANTLR_UINT64_LIT(0x0000003F00000680) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_40_in_statement529( FOLLOW_40_in_statement529_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_exp_in_statement531_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_exp_in_statement531( FOLLOW_exp_in_statement531_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_21_in_statement533_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_21_in_statement533( FOLLOW_21_in_statement533_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_exp_in_statement538_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_exp_in_statement538( FOLLOW_exp_in_statement538_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_21_in_statement540_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_21_in_statement540( FOLLOW_21_in_statement540_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_function_call_in_exp551_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_function_call_in_exp551( FOLLOW_function_call_in_exp551_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_variable_in_exp556_bits[]	= { ANTLR_UINT64_LIT(0x0000000000800002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_variable_in_exp556( FOLLOW_variable_in_exp556_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_23_in_exp559_bits[]	= { ANTLR_UINT64_LIT(0x0000003F00000680) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_23_in_exp559( FOLLOW_23_in_exp559_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_exp_in_exp561_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_exp_in_exp561( FOLLOW_exp_in_exp561_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_constructor_in_exp568_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_constructor_in_exp568( FOLLOW_constructor_in_exp568_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_number_in_exp573_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_number_in_exp573( FOLLOW_number_in_exp573_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_ID_in_variable586_bits[]	= { ANTLR_UINT64_LIT(0x0000000000080000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_ID_in_variable586( FOLLOW_ID_in_variable586_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_19_in_variable588_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000200) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_19_in_variable588( FOLLOW_19_in_variable588_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_variable_in_variable590_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_variable_in_variable590( FOLLOW_variable_in_variable590_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_ID_in_variable595_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_ID_in_variable595( FOLLOW_ID_in_variable595_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_ID_in_function_call605_bits[]	= { ANTLR_UINT64_LIT(0x0000000000010000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_ID_in_function_call605( FOLLOW_ID_in_function_call605_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_16_in_function_call607_bits[]	= { ANTLR_UINT64_LIT(0x0000003F00020680) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_16_in_function_call607( FOLLOW_16_in_function_call607_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_exp_in_function_call611_bits[]	= { ANTLR_UINT64_LIT(0x0000000000060000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_exp_in_function_call611( FOLLOW_exp_in_function_call611_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_18_in_function_call615_bits[]	= { ANTLR_UINT64_LIT(0x0000003F00000680) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_18_in_function_call615( FOLLOW_18_in_function_call615_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_exp_in_function_call617_bits[]	= { ANTLR_UINT64_LIT(0x0000000000060000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_exp_in_function_call617( FOLLOW_exp_in_function_call617_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_17_in_function_call625_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_17_in_function_call625( FOLLOW_17_in_function_call625_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_number_type_in_constructor638_bits[]	= { ANTLR_UINT64_LIT(0x0000000000010000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_number_type_in_constructor638( FOLLOW_number_type_in_constructor638_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_16_in_constructor640_bits[]	= { ANTLR_UINT64_LIT(0x0000003F00000680) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_16_in_constructor640( FOLLOW_16_in_constructor640_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_exp_in_constructor642_bits[]	= { ANTLR_UINT64_LIT(0x0000000000060000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_exp_in_constructor642( FOLLOW_exp_in_constructor642_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_18_in_constructor647_bits[]	= { ANTLR_UINT64_LIT(0x0000003F00000680) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_18_in_constructor647( FOLLOW_18_in_constructor647_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_exp_in_constructor649_bits[]	= { ANTLR_UINT64_LIT(0x0000000000060000) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_exp_in_constructor649( FOLLOW_exp_in_constructor649_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: HLSLParser  */
static	ANTLR_BITWORD FOLLOW_17_in_constructor654_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  HLSLParserImplTraits::BitsetListType FOLLOW_17_in_constructor654( FOLLOW_17_in_constructor654_bits, 1 );


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start translation_unit
 * HLSL.g:32:1: translation_unit : ( global_declaration )* ( technique )* ;
 */
void
HLSLParser::translation_unit()
{
        HLSLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // HLSL.g:33:2: ( ( global_declaration )* ( technique )* )
        // HLSL.g:33:4: ( global_declaration )* ( technique )*
        {
            // HLSL.g:33:4: ( global_declaration )*

            for (;;)
            {
                int alt1=2;
                switch ( this->LA(1) )
                {
                case ID:
                case 29:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                case 37:
                case 41:
                case 42:
                	{
                		alt1=1;
                	}
                    break;

                }

                switch (alt1)
                {
            	case 1:
            	    // HLSL.g:33:4: global_declaration
            	    {
            	        this->followPush(FOLLOW_global_declaration_in_translation_unit66);
            	        global_declaration();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletranslation_unitEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop1;	/* break out of the loop */
            	    break;
                }
            }
            loop1: ; /* Jump out to here if this rule does not match */


            // HLSL.g:33:24: ( technique )*

            for (;;)
            {
                int alt2=2;
                switch ( this->LA(1) )
                {
                case 43:
                	{
                		alt2=1;
                	}
                    break;

                }

                switch (alt2)
                {
            	case 1:
            	    // HLSL.g:33:24: technique
            	    {
            	        this->followPush(FOLLOW_technique_in_translation_unit69);
            	        technique();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletranslation_unitEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop2;	/* break out of the loop */
            	    break;
                }
            }
            loop2: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletranslation_unitEx; /* Prevent compiler warnings */
    ruletranslation_unitEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end translation_unit */

/**
 * $ANTLR start global_declaration
 * HLSL.g:36:1: global_declaration : ( type_definition | variable_declaration | function );
 */
void
HLSLParser::global_declaration()
{
        HLSLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  HLSL.g:37:2: ( type_definition | variable_declaration | function )

            ANTLR_UINT32 alt3;

            alt3=3;

            switch ( this->LA(1) )
            {
            case 42:
            	{
            		alt3=1;
            	}
                break;
            case 32:
            case 33:
            case 34:
            case 35:
            case 36:
            case 37:
            	{
            		switch ( this->LA(2) )
            		{
            		case ID:
            			{
            				switch ( this->LA(3) )
            				{
            				case 21:
            					{
            						alt3=2;
            					}
            				    break;
            				case 16:
            					{
            						alt3=3;
            					}
            				    break;

            				default:
            				    if (this->get_backtracking()>0)
            				    {
            				        this->set_failedflag( true );
            				        return ;
            				    }

            				    ExceptionBaseType* ex = new ANTLR_Exception< HLSLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            				    ex->set_decisionNum( 3 );
            				    ex->set_state( 5 );


            				    goto ruleglobal_declarationEx;

            				}

            			}
            		    break;

            		default:
            		    if (this->get_backtracking()>0)
            		    {
            		        this->set_failedflag( true );
            		        return ;
            		    }

            		    ExceptionBaseType* ex = new ANTLR_Exception< HLSLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 3 );
            		    ex->set_state( 2 );


            		    goto ruleglobal_declarationEx;

            		}

            	}
                break;
            case ID:
            	{
            		switch ( this->LA(2) )
            		{
            		case ID:
            			{
            				switch ( this->LA(3) )
            				{
            				case 21:
            					{
            						alt3=2;
            					}
            				    break;
            				case 16:
            					{
            						alt3=3;
            					}
            				    break;

            				default:
            				    if (this->get_backtracking()>0)
            				    {
            				        this->set_failedflag( true );
            				        return ;
            				    }

            				    ExceptionBaseType* ex = new ANTLR_Exception< HLSLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            				    ex->set_decisionNum( 3 );
            				    ex->set_state( 5 );


            				    goto ruleglobal_declarationEx;

            				}

            			}
            		    break;

            		default:
            		    if (this->get_backtracking()>0)
            		    {
            		        this->set_failedflag( true );
            		        return ;
            		    }

            		    ExceptionBaseType* ex = new ANTLR_Exception< HLSLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 3 );
            		    ex->set_state( 3 );


            		    goto ruleglobal_declarationEx;

            		}

            	}
                break;
            case 29:
            case 41:
            	{
            		alt3=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< HLSLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 3 );
                ex->set_state( 0 );


                goto ruleglobal_declarationEx;

            }

            switch (alt3)
            {
        	case 1:
        	    // HLSL.g:37:4: type_definition
        	    {
        	        this->followPush(FOLLOW_type_definition_in_global_declaration82);
        	        type_definition();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleglobal_declarationEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // HLSL.g:38:4: variable_declaration
        	    {
        	        this->followPush(FOLLOW_variable_declaration_in_global_declaration87);
        	        variable_declaration();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleglobal_declarationEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // HLSL.g:39:4: function
        	    {
        	        this->followPush(FOLLOW_function_in_global_declaration92);
        	        function();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleglobal_declarationEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleglobal_declarationEx; /* Prevent compiler warnings */
    ruleglobal_declarationEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end global_declaration */

/**
 * $ANTLR start technique
 * HLSL.g:42:1: technique : 'technique' ID LEFT_CURLY ( pass )* RIGHT_CURLY ;
 */
void
HLSLParser::technique()
{
        HLSLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    const CommonTokenType*    ID1;

    /* Initialize rule variables
     */

    ID1       = NULL;


 
    {
        // HLSL.g:43:2: ( 'technique' ID LEFT_CURLY ( pass )* RIGHT_CURLY )
        // HLSL.g:43:4: 'technique' ID LEFT_CURLY ( pass )* RIGHT_CURLY
        {
             this->matchToken(43, &FOLLOW_43_in_technique104);
            if  (this->hasException())
            {
                goto ruletechniqueEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            ID1 =  this->matchToken(ID, &FOLLOW_ID_in_technique106);
            if  (this->hasException())
            {
                goto ruletechniqueEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_CURLY, &FOLLOW_LEFT_CURLY_in_technique108);
            if  (this->hasException())
            {
                goto ruletechniqueEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            if ( this->get_backtracking()==0 )
            {
                 Listener->StartTechnique( (ID1->getText()) ); 
            }


            // HLSL.g:43:72: ( pass )*

            for (;;)
            {
                int alt4=2;
                switch ( this->LA(1) )
                {
                case 38:
                	{
                		alt4=1;
                	}
                    break;

                }

                switch (alt4)
                {
            	case 1:
            	    // HLSL.g:43:74: pass
            	    {
            	        this->followPush(FOLLOW_pass_in_technique114);
            	        pass();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletechniqueEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop4;	/* break out of the loop */
            	    break;
                }
            }
            loop4: ; /* Jump out to here if this rule does not match */


             this->matchToken(RIGHT_CURLY, &FOLLOW_RIGHT_CURLY_in_technique119);
            if  (this->hasException())
            {
                goto ruletechniqueEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            if ( this->get_backtracking()==0 )
            {
                 Listener->EndTechnique(); 
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletechniqueEx; /* Prevent compiler warnings */
    ruletechniqueEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end technique */

/**
 * $ANTLR start pass
 * HLSL.g:46:1: pass : 'pass' ID LEFT_CURLY vertex_shader_definition pixel_shader_definition RIGHT_CURLY ;
 */
void
HLSLParser::pass()
{
        HLSLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    const CommonTokenType*    ID2;

    /* Initialize rule variables
     */

    ID2       = NULL;


 
    {
        // HLSL.g:46:7: ( 'pass' ID LEFT_CURLY vertex_shader_definition pixel_shader_definition RIGHT_CURLY )
        // HLSL.g:46:9: 'pass' ID LEFT_CURLY vertex_shader_definition pixel_shader_definition RIGHT_CURLY
        {
             this->matchToken(38, &FOLLOW_38_in_pass132);
            if  (this->hasException())
            {
                goto rulepassEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            ID2 =  this->matchToken(ID, &FOLLOW_ID_in_pass134);
            if  (this->hasException())
            {
                goto rulepassEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            if ( this->get_backtracking()==0 )
            {
                 Listener->StartPass( (ID2->getText()) ); 
            }


             this->matchToken(LEFT_CURLY, &FOLLOW_LEFT_CURLY_in_pass138);
            if  (this->hasException())
            {
                goto rulepassEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_vertex_shader_definition_in_pass140);
            vertex_shader_definition();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepassEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_pixel_shader_definition_in_pass142);
            pixel_shader_definition();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepassEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(RIGHT_CURLY, &FOLLOW_RIGHT_CURLY_in_pass144);
            if  (this->hasException())
            {
                goto rulepassEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            if ( this->get_backtracking()==0 )
            {
                 Listener->EndPass(); 
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepassEx; /* Prevent compiler warnings */
    rulepassEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end pass */

/**
 * $ANTLR start vertex_shader_definition
 * HLSL.g:49:1: vertex_shader_definition : 'VertexShader' '=' 'compile' 'vs_3_0' ID '(' ')' ';' ;
 */
void
HLSLParser::vertex_shader_definition()
{
        HLSLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    const CommonTokenType*    ID3;

    /* Initialize rule variables
     */

    ID3       = NULL;


 
    {
        // HLSL.g:50:2: ( 'VertexShader' '=' 'compile' 'vs_3_0' ID '(' ')' ';' )
        // HLSL.g:50:4: 'VertexShader' '=' 'compile' 'vs_3_0' ID '(' ')' ';'
        {
             this->matchToken(30, &FOLLOW_30_in_vertex_shader_definition158);
            if  (this->hasException())
            {
                goto rulevertex_shader_definitionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(23, &FOLLOW_23_in_vertex_shader_definition160);
            if  (this->hasException())
            {
                goto rulevertex_shader_definitionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(31, &FOLLOW_31_in_vertex_shader_definition162);
            if  (this->hasException())
            {
                goto rulevertex_shader_definitionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(44, &FOLLOW_44_in_vertex_shader_definition164);
            if  (this->hasException())
            {
                goto rulevertex_shader_definitionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            ID3 =  this->matchToken(ID, &FOLLOW_ID_in_vertex_shader_definition166);
            if  (this->hasException())
            {
                goto rulevertex_shader_definitionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(16, &FOLLOW_16_in_vertex_shader_definition168);
            if  (this->hasException())
            {
                goto rulevertex_shader_definitionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(17, &FOLLOW_17_in_vertex_shader_definition170);
            if  (this->hasException())
            {
                goto rulevertex_shader_definitionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(21, &FOLLOW_21_in_vertex_shader_definition172);
            if  (this->hasException())
            {
                goto rulevertex_shader_definitionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            if ( this->get_backtracking()==0 )
            {
                 Listener->SetVertexShader( (ID3->getText()) ); 
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulevertex_shader_definitionEx; /* Prevent compiler warnings */
    rulevertex_shader_definitionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end vertex_shader_definition */

/**
 * $ANTLR start pixel_shader_definition
 * HLSL.g:52:1: pixel_shader_definition : 'PixelShader' '=' 'compile' 'ps_3_0' ID '(' ')' ';' ;
 */
void
HLSLParser::pixel_shader_definition()
{
        HLSLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    const CommonTokenType*    ID4;

    /* Initialize rule variables
     */

    ID4       = NULL;


 
    {
        // HLSL.g:53:2: ( 'PixelShader' '=' 'compile' 'ps_3_0' ID '(' ')' ';' )
        // HLSL.g:53:9: 'PixelShader' '=' 'compile' 'ps_3_0' ID '(' ')' ';'
        {
             this->matchToken(27, &FOLLOW_27_in_pixel_shader_definition196);
            if  (this->hasException())
            {
                goto rulepixel_shader_definitionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(23, &FOLLOW_23_in_pixel_shader_definition198);
            if  (this->hasException())
            {
                goto rulepixel_shader_definitionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(31, &FOLLOW_31_in_pixel_shader_definition200);
            if  (this->hasException())
            {
                goto rulepixel_shader_definitionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(39, &FOLLOW_39_in_pixel_shader_definition202);
            if  (this->hasException())
            {
                goto rulepixel_shader_definitionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            ID4 =  this->matchToken(ID, &FOLLOW_ID_in_pixel_shader_definition204);
            if  (this->hasException())
            {
                goto rulepixel_shader_definitionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(16, &FOLLOW_16_in_pixel_shader_definition206);
            if  (this->hasException())
            {
                goto rulepixel_shader_definitionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(17, &FOLLOW_17_in_pixel_shader_definition208);
            if  (this->hasException())
            {
                goto rulepixel_shader_definitionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(21, &FOLLOW_21_in_pixel_shader_definition210);
            if  (this->hasException())
            {
                goto rulepixel_shader_definitionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            if ( this->get_backtracking()==0 )
            {
                 Listener->SetPixelShader( (ID4->getText()) ); 
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepixel_shader_definitionEx; /* Prevent compiler warnings */
    rulepixel_shader_definitionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end pixel_shader_definition */

/**
 * $ANTLR start type_definition
 * HLSL.g:55:1: type_definition : 'struct' ID LEFT_CURLY ( field_declaration )+ RIGHT_CURLY ';' ;
 */
void
HLSLParser::type_definition()
{
        HLSLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // HLSL.g:56:2: ( 'struct' ID LEFT_CURLY ( field_declaration )+ RIGHT_CURLY ';' )
        // HLSL.g:56:4: 'struct' ID LEFT_CURLY ( field_declaration )+ RIGHT_CURLY ';'
        {
             this->matchToken(42, &FOLLOW_42_in_type_definition220);
            if  (this->hasException())
            {
                goto ruletype_definitionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(ID, &FOLLOW_ID_in_type_definition222);
            if  (this->hasException())
            {
                goto ruletype_definitionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_CURLY, &FOLLOW_LEFT_CURLY_in_type_definition224);
            if  (this->hasException())
            {
                goto ruletype_definitionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // HLSL.g:56:27: ( field_declaration )+
            {
                int cnt5=0;

                for (;;)
                {
                    int alt5=2;
            	switch ( this->LA(1) )
            	{
            	case ID:
            	case 32:
            	case 33:
            	case 34:
            	case 35:
            	case 36:
            	case 37:
            		{
            			alt5=1;
            		}
            	    break;

            	}

            	switch (alt5)
            	{
            	    case 1:
            	        // HLSL.g:56:27: field_declaration
            	        {
            	            this->followPush(FOLLOW_field_declaration_in_type_definition226);
            	            field_declaration();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto ruletype_definitionEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt5 >= 1 )
            		{
            		    goto loop5;
            		}
            		if (this->get_backtracking()>0)
            		{
            		    this->set_failedflag( true );
            		    return ;
            		}

            		/* mismatchedSetEx()
            		 */
            		new ANTLR_Exception< HLSLParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


            		goto ruletype_definitionEx;
            	}
            	cnt5++;
                }
                loop5: ;	/* Jump to here if this rule does not match */
            }

             this->matchToken(RIGHT_CURLY, &FOLLOW_RIGHT_CURLY_in_type_definition229);
            if  (this->hasException())
            {
                goto ruletype_definitionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(21, &FOLLOW_21_in_type_definition231);
            if  (this->hasException())
            {
                goto ruletype_definitionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletype_definitionEx; /* Prevent compiler warnings */
    ruletype_definitionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end type_definition */

/**
 * $ANTLR start variable_declaration
 * HLSL.g:59:1: variable_declaration : ( type ID ';' | texture_type ID ';' | sampler );
 */
void
HLSLParser::variable_declaration()
{
        HLSLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    const CommonTokenType*    ID6;
    HLSLParser_texture_type_return texture_type5;
    typedef	HLSLParser_texture_type_return RETURN_TYPE_texture_type5;

    /* Initialize rule variables
     */

    ID6       = NULL;


 
    {
        {
            //  HLSL.g:60:2: ( type ID ';' | texture_type ID ';' | sampler )

            ANTLR_UINT32 alt6;

            alt6=3;

            switch ( this->LA(1) )
            {
            case ID:
            case 32:
            case 33:
            case 34:
            case 35:
            case 36:
            case 37:
            	{
            		alt6=1;
            	}
                break;
            case 29:
            	{
            		alt6=2;
            	}
                break;
            case 41:
            	{
            		alt6=3;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< HLSLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 6 );
                ex->set_state( 0 );


                goto rulevariable_declarationEx;

            }

            switch (alt6)
            {
        	case 1:
        	    // HLSL.g:60:4: type ID ';'
        	    {
        	        this->followPush(FOLLOW_type_in_variable_declaration243);
        	        type();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulevariable_declarationEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(ID, &FOLLOW_ID_in_variable_declaration245);
        	        if  (this->hasException())
        	        {
        	            goto rulevariable_declarationEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(21, &FOLLOW_21_in_variable_declaration247);
        	        if  (this->hasException())
        	        {
        	            goto rulevariable_declarationEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // HLSL.g:61:5: texture_type ID ';'
        	    {
        	        this->followPush(FOLLOW_texture_type_in_variable_declaration253);
        	        texture_type5=texture_type();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulevariable_declarationEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        ID6 =  this->matchToken(ID, &FOLLOW_ID_in_variable_declaration255);
        	        if  (this->hasException())
        	        {
        	            goto rulevariable_declarationEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(21, &FOLLOW_21_in_variable_declaration257);
        	        if  (this->hasException())
        	        {
        	            goto rulevariable_declarationEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        if ( this->get_backtracking()==0 )
        	        {
        	             std::cout << (this->get_strstream()->toStringTT(texture_type5.start, texture_type5.stop))
        	             << " \"" << (ID6->getText()) << "\";" << std::endl; 
        	        }


        	    }
        	    break;
        	case 3:
        	    // HLSL.g:62:4: sampler
        	    {
        	        this->followPush(FOLLOW_sampler_in_variable_declaration264);
        	        sampler();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulevariable_declarationEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulevariable_declarationEx; /* Prevent compiler warnings */
    rulevariable_declarationEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end variable_declaration */

/**
 * $ANTLR start sampler
 * HLSL.g:64:1: sampler : sampler_type ID LEFT_CURLY ( sampler_parameter )* RIGHT_CURLY ';' ;
 */
void
HLSLParser::sampler()
{
        HLSLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // HLSL.g:65:2: ( sampler_type ID LEFT_CURLY ( sampler_parameter )* RIGHT_CURLY ';' )
        // HLSL.g:65:4: sampler_type ID LEFT_CURLY ( sampler_parameter )* RIGHT_CURLY ';'
        {
            this->followPush(FOLLOW_sampler_type_in_sampler275);
            sampler_type();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesamplerEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(ID, &FOLLOW_ID_in_sampler277);
            if  (this->hasException())
            {
                goto rulesamplerEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_CURLY, &FOLLOW_LEFT_CURLY_in_sampler279);
            if  (this->hasException())
            {
                goto rulesamplerEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // HLSL.g:65:31: ( sampler_parameter )*

            for (;;)
            {
                int alt7=2;
                switch ( this->LA(1) )
                {
                case ID:
                case 29:
                	{
                		alt7=1;
                	}
                    break;

                }

                switch (alt7)
                {
            	case 1:
            	    // HLSL.g:65:31: sampler_parameter
            	    {
            	        this->followPush(FOLLOW_sampler_parameter_in_sampler281);
            	        sampler_parameter();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesamplerEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop7;	/* break out of the loop */
            	    break;
                }
            }
            loop7: ; /* Jump out to here if this rule does not match */


             this->matchToken(RIGHT_CURLY, &FOLLOW_RIGHT_CURLY_in_sampler284);
            if  (this->hasException())
            {
                goto rulesamplerEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(21, &FOLLOW_21_in_sampler286);
            if  (this->hasException())
            {
                goto rulesamplerEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesamplerEx; /* Prevent compiler warnings */
    rulesamplerEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end sampler */

/**
 * $ANTLR start sampler_type
 * HLSL.g:68:1: sampler_type : 'sampler2D' ;
 */
void
HLSLParser::sampler_type()
{
        HLSLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // HLSL.g:69:2: ( 'sampler2D' )
        // HLSL.g:69:4: 'sampler2D'
        {
             this->matchToken(41, &FOLLOW_41_in_sampler_type299);
            if  (this->hasException())
            {
                goto rulesampler_typeEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesampler_typeEx; /* Prevent compiler warnings */
    rulesampler_typeEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end sampler_type */

/**
 * $ANTLR start sampler_parameter
 * HLSL.g:72:1: sampler_parameter : ( 'Texture' '=' '<' ID '>' ';' | ID '=' ID ';' );
 */
void
HLSLParser::sampler_parameter()
{
        HLSLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  HLSL.g:73:2: ( 'Texture' '=' '<' ID '>' ';' | ID '=' ID ';' )

            ANTLR_UINT32 alt8;

            alt8=2;

            switch ( this->LA(1) )
            {
            case 29:
            	{
            		alt8=1;
            	}
                break;
            case ID:
            	{
            		alt8=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< HLSLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 8 );
                ex->set_state( 0 );


                goto rulesampler_parameterEx;

            }

            switch (alt8)
            {
        	case 1:
        	    // HLSL.g:73:4: 'Texture' '=' '<' ID '>' ';'
        	    {
        	         this->matchToken(29, &FOLLOW_29_in_sampler_parameter311);
        	        if  (this->hasException())
        	        {
        	            goto rulesampler_parameterEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(23, &FOLLOW_23_in_sampler_parameter313);
        	        if  (this->hasException())
        	        {
        	            goto rulesampler_parameterEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(22, &FOLLOW_22_in_sampler_parameter315);
        	        if  (this->hasException())
        	        {
        	            goto rulesampler_parameterEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(ID, &FOLLOW_ID_in_sampler_parameter317);
        	        if  (this->hasException())
        	        {
        	            goto rulesampler_parameterEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(24, &FOLLOW_24_in_sampler_parameter319);
        	        if  (this->hasException())
        	        {
        	            goto rulesampler_parameterEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(21, &FOLLOW_21_in_sampler_parameter321);
        	        if  (this->hasException())
        	        {
        	            goto rulesampler_parameterEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // HLSL.g:74:4: ID '=' ID ';'
        	    {
        	         this->matchToken(ID, &FOLLOW_ID_in_sampler_parameter326);
        	        if  (this->hasException())
        	        {
        	            goto rulesampler_parameterEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(23, &FOLLOW_23_in_sampler_parameter328);
        	        if  (this->hasException())
        	        {
        	            goto rulesampler_parameterEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(ID, &FOLLOW_ID_in_sampler_parameter330);
        	        if  (this->hasException())
        	        {
        	            goto rulesampler_parameterEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(21, &FOLLOW_21_in_sampler_parameter332);
        	        if  (this->hasException())
        	        {
        	            goto rulesampler_parameterEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulesampler_parameterEx; /* Prevent compiler warnings */
    rulesampler_parameterEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end sampler_parameter */

/**
 * $ANTLR start number_type
 * HLSL.g:76:1: number_type : ( 'float' | 'float2' | 'float3' | 'float4' | 'float1x1' | 'float1x2' );
 */
void
HLSLParser::number_type()
{
        HLSLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // HLSL.g:77:2: ( 'float' | 'float2' | 'float3' | 'float4' | 'float1x1' | 'float1x2' )
        // HLSL.g:
        {
            if ( ((this->LA(1) >= 32) && (this->LA(1) <= 37)) )
            {
                this->consume();
                this->set_perror_recovery(false);
                 this->set_failedflag(false); 

            }
            else
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                new ANTLR_Exception< HLSLParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
                this->get_exception()->set_expectingSet(NULL);

                goto rulenumber_typeEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenumber_typeEx; /* Prevent compiler warnings */
    rulenumber_typeEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end number_type */

/**
 * $ANTLR start texture_type
 * HLSL.g:85:1: texture_type : 'Texture' ;
 */
HLSLParser_texture_type_return
HLSLParser::texture_type()
{
    HLSLParser_texture_type_return retval(this);


    /* Initialize rule variables
     */

    retval.call_start_placeholder(); 



 
    {
        // HLSL.g:86:2: ( 'Texture' )
        // HLSL.g:86:4: 'Texture'
        {
             this->matchToken(29, &FOLLOW_29_in_texture_type381);
            if  (this->hasException())
            {
                goto ruletexture_typeEx;
            }
            if (this->hasFailed())
            {
                return retval;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletexture_typeEx; /* Prevent compiler warnings */
    ruletexture_typeEx: ;
    retval.call_stop_placeholder();



    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return retval;
}
/* $ANTLR end texture_type */

/**
 * $ANTLR start type
 * HLSL.g:89:1: type : ( number_type | ID );
 */
void
HLSLParser::type()
{
        HLSLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  HLSL.g:89:6: ( number_type | ID )

            ANTLR_UINT32 alt9;

            alt9=2;

            switch ( this->LA(1) )
            {
            case 32:
            case 33:
            case 34:
            case 35:
            case 36:
            case 37:
            	{
            		alt9=1;
            	}
                break;
            case ID:
            	{
            		alt9=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< HLSLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 9 );
                ex->set_state( 0 );


                goto ruletypeEx;

            }

            switch (alt9)
            {
        	case 1:
        	    // HLSL.g:89:8: number_type
        	    {
        	        this->followPush(FOLLOW_number_type_in_type391);
        	        number_type();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletypeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // HLSL.g:90:4: ID
        	    {
        	         this->matchToken(ID, &FOLLOW_ID_in_type396);
        	        if  (this->hasException())
        	        {
        	            goto ruletypeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruletypeEx; /* Prevent compiler warnings */
    ruletypeEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end type */

/**
 * $ANTLR start field_declaration
 * HLSL.g:93:1: field_declaration : type ID ':' semantic ';' ;
 */
void
HLSLParser::field_declaration()
{
        HLSLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // HLSL.g:94:2: ( type ID ':' semantic ';' )
        // HLSL.g:94:5: type ID ':' semantic ';'
        {
            this->followPush(FOLLOW_type_in_field_declaration409);
            type();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefield_declarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(ID, &FOLLOW_ID_in_field_declaration411);
            if  (this->hasException())
            {
                goto rulefield_declarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(20, &FOLLOW_20_in_field_declaration413);
            if  (this->hasException())
            {
                goto rulefield_declarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_semantic_in_field_declaration415);
            semantic();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefield_declarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(21, &FOLLOW_21_in_field_declaration417);
            if  (this->hasException())
            {
                goto rulefield_declarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefield_declarationEx; /* Prevent compiler warnings */
    rulefield_declarationEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end field_declaration */

/**
 * $ANTLR start semantic
 * HLSL.g:97:1: semantic : ( 'POSITION' | 'TEXCOORD0' | 'COLOR0' );
 */
void
HLSLParser::semantic()
{
        HLSLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // HLSL.g:98:2: ( 'POSITION' | 'TEXCOORD0' | 'COLOR0' )
        // HLSL.g:
        {
            if ( ((this->LA(1) >= 25) && (this->LA(1) <= 26)) || this->LA(1) == 28 )
            {
                this->consume();
                this->set_perror_recovery(false);
                 this->set_failedflag(false); 

            }
            else
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                new ANTLR_Exception< HLSLParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
                this->get_exception()->set_expectingSet(NULL);

                goto rulesemanticEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesemanticEx; /* Prevent compiler warnings */
    rulesemanticEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end semantic */

/**
 * $ANTLR start function
 * HLSL.g:103:1: function : type ID '(' ( parameter_declaration ( ',' parameter_declaration )* )? ')' ( ':' semantic )? '{' ( statement )* '}' ;
 */
void
HLSLParser::function()
{
        HLSLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // HLSL.g:104:2: ( type ID '(' ( parameter_declaration ( ',' parameter_declaration )* )? ')' ( ':' semantic )? '{' ( statement )* '}' )
        // HLSL.g:104:4: type ID '(' ( parameter_declaration ( ',' parameter_declaration )* )? ')' ( ':' semantic )? '{' ( statement )* '}'
        {
            this->followPush(FOLLOW_type_in_function454);
            type();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefunctionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(ID, &FOLLOW_ID_in_function456);
            if  (this->hasException())
            {
                goto rulefunctionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(16, &FOLLOW_16_in_function458);
            if  (this->hasException())
            {
                goto rulefunctionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // HLSL.g:104:16: ( parameter_declaration ( ',' parameter_declaration )* )?
            {
                int alt11=2;
                switch ( this->LA(1) )
                {
                    case ID:
                    case 32:
                    case 33:
                    case 34:
                    case 35:
                    case 36:
                    case 37:
                    	{
                    		alt11=1;
                    	}
                        break;
                }

                switch (alt11)
                {
            	case 1:
            	    // HLSL.g:104:18: parameter_declaration ( ',' parameter_declaration )*
            	    {
            	        this->followPush(FOLLOW_parameter_declaration_in_function462);
            	        parameter_declaration();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunctionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // HLSL.g:104:40: ( ',' parameter_declaration )*

            	        for (;;)
            	        {
            	            int alt10=2;
            	            switch ( this->LA(1) )
            	            {
            	            case 18:
            	            	{
            	            		alt10=1;
            	            	}
            	                break;

            	            }

            	            switch (alt10)
            	            {
            	        	case 1:
            	        	    // HLSL.g:104:42: ',' parameter_declaration
            	        	    {
            	        	         this->matchToken(18, &FOLLOW_18_in_function466);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefunctionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_parameter_declaration_in_function468);
            	        	        parameter_declaration();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefunctionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop10;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop10: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

             this->matchToken(17, &FOLLOW_17_in_function476);
            if  (this->hasException())
            {
                goto rulefunctionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // HLSL.g:104:78: ( ':' semantic )?
            {
                int alt12=2;
                switch ( this->LA(1) )
                {
                    case 20:
                    	{
                    		alt12=1;
                    	}
                        break;
                }

                switch (alt12)
                {
            	case 1:
            	    // HLSL.g:104:80: ':' semantic
            	    {
            	         this->matchToken(20, &FOLLOW_20_in_function480);
            	        if  (this->hasException())
            	        {
            	            goto rulefunctionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_semantic_in_function482);
            	        semantic();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunctionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(LEFT_CURLY, &FOLLOW_LEFT_CURLY_in_function487);
            if  (this->hasException())
            {
                goto rulefunctionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // HLSL.g:104:100: ( statement )*

            for (;;)
            {
                int alt13=2;
                switch ( this->LA(1) )
                {
                case FLOAT:
                case ID:
                case INT:
                case 29:
                case 32:
                case 33:
                case 34:
                case 35:
                case 36:
                case 37:
                case 40:
                case 41:
                	{
                		alt13=1;
                	}
                    break;

                }

                switch (alt13)
                {
            	case 1:
            	    // HLSL.g:104:100: statement
            	    {
            	        this->followPush(FOLLOW_statement_in_function489);
            	        statement();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunctionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop13;	/* break out of the loop */
            	    break;
                }
            }
            loop13: ; /* Jump out to here if this rule does not match */


             this->matchToken(RIGHT_CURLY, &FOLLOW_RIGHT_CURLY_in_function492);
            if  (this->hasException())
            {
                goto rulefunctionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefunctionEx; /* Prevent compiler warnings */
    rulefunctionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end function */

/**
 * $ANTLR start parameter_declaration
 * HLSL.g:106:1: parameter_declaration : type ID ( ':' semantic )? ;
 */
void
HLSLParser::parameter_declaration()
{
        HLSLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // HLSL.g:107:2: ( type ID ( ':' semantic )? )
        // HLSL.g:107:4: type ID ( ':' semantic )?
        {
            this->followPush(FOLLOW_type_in_parameter_declaration502);
            type();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleparameter_declarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(ID, &FOLLOW_ID_in_parameter_declaration504);
            if  (this->hasException())
            {
                goto ruleparameter_declarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // HLSL.g:107:12: ( ':' semantic )?
            {
                int alt14=2;
                switch ( this->LA(1) )
                {
                    case 20:
                    	{
                    		alt14=1;
                    	}
                        break;
                }

                switch (alt14)
                {
            	case 1:
            	    // HLSL.g:107:14: ':' semantic
            	    {
            	         this->matchToken(20, &FOLLOW_20_in_parameter_declaration508);
            	        if  (this->hasException())
            	        {
            	            goto ruleparameter_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_semantic_in_parameter_declaration510);
            	        semantic();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleparameter_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleparameter_declarationEx; /* Prevent compiler warnings */
    ruleparameter_declarationEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end parameter_declaration */

/**
 * $ANTLR start statement
 * HLSL.g:110:1: statement : ( variable_declaration | 'return' exp ';' | exp ';' );
 */
void
HLSLParser::statement()
{
        HLSLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  HLSL.g:111:2: ( variable_declaration | 'return' exp ';' | exp ';' )

            ANTLR_UINT32 alt15;

            alt15=3;

            switch ( this->LA(1) )
            {
            case 32:
            case 33:
            case 34:
            case 35:
            case 36:
            case 37:
            	{
            		switch ( this->LA(2) )
            		{
            		case ID:
            			{
            				alt15=1;
            			}
            		    break;
            		case 16:
            			{
            				alt15=3;
            			}
            		    break;

            		default:
            		    if (this->get_backtracking()>0)
            		    {
            		        this->set_failedflag( true );
            		        return ;
            		    }

            		    ExceptionBaseType* ex = new ANTLR_Exception< HLSLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 15 );
            		    ex->set_state( 1 );


            		    goto rulestatementEx;

            		}

            	}
                break;
            case ID:
            	{
            		switch ( this->LA(2) )
            		{
            		case 16:
            		case 19:
            		case 21:
            		case 23:
            			{
            				alt15=3;
            			}
            		    break;
            		case ID:
            			{
            				alt15=1;
            			}
            		    break;

            		default:
            		    if (this->get_backtracking()>0)
            		    {
            		        this->set_failedflag( true );
            		        return ;
            		    }

            		    ExceptionBaseType* ex = new ANTLR_Exception< HLSLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 15 );
            		    ex->set_state( 2 );


            		    goto rulestatementEx;

            		}

            	}
                break;
            case 29:
            case 41:
            	{
            		alt15=1;
            	}
                break;
            case 40:
            	{
            		alt15=2;
            	}
                break;
            case FLOAT:
            case INT:
            	{
            		alt15=3;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< HLSLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 15 );
                ex->set_state( 0 );


                goto rulestatementEx;

            }

            switch (alt15)
            {
        	case 1:
        	    // HLSL.g:111:4: variable_declaration
        	    {
        	        this->followPush(FOLLOW_variable_declaration_in_statement524);
        	        variable_declaration();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // HLSL.g:112:4: 'return' exp ';'
        	    {
        	         this->matchToken(40, &FOLLOW_40_in_statement529);
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_exp_in_statement531);
        	        exp();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(21, &FOLLOW_21_in_statement533);
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // HLSL.g:113:4: exp ';'
        	    {
        	        this->followPush(FOLLOW_exp_in_statement538);
        	        exp();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(21, &FOLLOW_21_in_statement540);
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulestatementEx; /* Prevent compiler warnings */
    rulestatementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end statement */

/**
 * $ANTLR start exp
 * HLSL.g:115:1: exp : ( function_call | variable ( '=' exp )? | constructor | number );
 */
void
HLSLParser::exp()
{
        HLSLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  HLSL.g:115:6: ( function_call | variable ( '=' exp )? | constructor | number )

            ANTLR_UINT32 alt17;

            alt17=4;

            switch ( this->LA(1) )
            {
            case ID:
            	{
            		switch ( this->LA(2) )
            		{
            		case 16:
            			{
            				alt17=1;
            			}
            		    break;
            		case EOF:
            		case 17:
            		case 18:
            		case 19:
            		case 21:
            		case 23:
            			{
            				alt17=2;
            			}
            		    break;

            		default:
            		    if (this->get_backtracking()>0)
            		    {
            		        this->set_failedflag( true );
            		        return ;
            		    }

            		    ExceptionBaseType* ex = new ANTLR_Exception< HLSLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 17 );
            		    ex->set_state( 1 );


            		    goto ruleexpEx;

            		}

            	}
                break;
            case 32:
            case 33:
            case 34:
            case 35:
            case 36:
            case 37:
            	{
            		alt17=3;
            	}
                break;
            case FLOAT:
            case INT:
            	{
            		alt17=4;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< HLSLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 17 );
                ex->set_state( 0 );


                goto ruleexpEx;

            }

            switch (alt17)
            {
        	case 1:
        	    // HLSL.g:116:2: function_call
        	    {
        	        this->followPush(FOLLOW_function_call_in_exp551);
        	        function_call();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleexpEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // HLSL.g:117:4: variable ( '=' exp )?
        	    {
        	        this->followPush(FOLLOW_variable_in_exp556);
        	        variable();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleexpEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // HLSL.g:117:13: ( '=' exp )?
        	        {
        	            int alt16=2;
        	            switch ( this->LA(1) )
        	            {
        	                case 23:
        	                	{
        	                		alt16=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt16)
        	            {
        	        	case 1:
        	        	    // HLSL.g:117:14: '=' exp
        	        	    {
        	        	         this->matchToken(23, &FOLLOW_23_in_exp559);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleexpEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_exp_in_exp561);
        	        	        exp();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleexpEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 3:
        	    // HLSL.g:118:4: constructor
        	    {
        	        this->followPush(FOLLOW_constructor_in_exp568);
        	        constructor();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleexpEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 4:
        	    // HLSL.g:119:4: number
        	    {
        	        this->followPush(FOLLOW_number_in_exp573);
        	        number();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleexpEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleexpEx; /* Prevent compiler warnings */
    ruleexpEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end exp */

/**
 * $ANTLR start variable
 * HLSL.g:122:1: variable : ( ID '.' variable | ID );
 */
void
HLSLParser::variable()
{
        HLSLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  HLSL.g:123:2: ( ID '.' variable | ID )

            ANTLR_UINT32 alt18;

            alt18=2;

            switch ( this->LA(1) )
            {
            case ID:
            	{
            		switch ( this->LA(2) )
            		{
            		case 19:
            			{
            				alt18=1;
            			}
            		    break;
            		case EOF:
            		case 17:
            		case 18:
            		case 21:
            		case 23:
            			{
            				alt18=2;
            			}
            		    break;

            		default:
            		    if (this->get_backtracking()>0)
            		    {
            		        this->set_failedflag( true );
            		        return ;
            		    }

            		    ExceptionBaseType* ex = new ANTLR_Exception< HLSLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 18 );
            		    ex->set_state( 1 );


            		    goto rulevariableEx;

            		}

            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< HLSLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 18 );
                ex->set_state( 0 );


                goto rulevariableEx;

            }

            switch (alt18)
            {
        	case 1:
        	    // HLSL.g:123:4: ID '.' variable
        	    {
        	         this->matchToken(ID, &FOLLOW_ID_in_variable586);
        	        if  (this->hasException())
        	        {
        	            goto rulevariableEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(19, &FOLLOW_19_in_variable588);
        	        if  (this->hasException())
        	        {
        	            goto rulevariableEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_variable_in_variable590);
        	        variable();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulevariableEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // HLSL.g:124:4: ID
        	    {
        	         this->matchToken(ID, &FOLLOW_ID_in_variable595);
        	        if  (this->hasException())
        	        {
        	            goto rulevariableEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulevariableEx; /* Prevent compiler warnings */
    rulevariableEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end variable */

/**
 * $ANTLR start function_call
 * HLSL.g:126:1: function_call : ID '(' ( exp ( ',' exp )* )? ')' ;
 */
void
HLSLParser::function_call()
{
        HLSLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // HLSL.g:127:2: ( ID '(' ( exp ( ',' exp )* )? ')' )
        // HLSL.g:127:4: ID '(' ( exp ( ',' exp )* )? ')'
        {
             this->matchToken(ID, &FOLLOW_ID_in_function_call605);
            if  (this->hasException())
            {
                goto rulefunction_callEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(16, &FOLLOW_16_in_function_call607);
            if  (this->hasException())
            {
                goto rulefunction_callEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // HLSL.g:127:11: ( exp ( ',' exp )* )?
            {
                int alt20=2;
                switch ( this->LA(1) )
                {
                    case FLOAT:
                    case ID:
                    case INT:
                    case 32:
                    case 33:
                    case 34:
                    case 35:
                    case 36:
                    case 37:
                    	{
                    		alt20=1;
                    	}
                        break;
                }

                switch (alt20)
                {
            	case 1:
            	    // HLSL.g:127:13: exp ( ',' exp )*
            	    {
            	        this->followPush(FOLLOW_exp_in_function_call611);
            	        exp();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_callEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // HLSL.g:127:17: ( ',' exp )*

            	        for (;;)
            	        {
            	            int alt19=2;
            	            switch ( this->LA(1) )
            	            {
            	            case 18:
            	            	{
            	            		alt19=1;
            	            	}
            	                break;

            	            }

            	            switch (alt19)
            	            {
            	        	case 1:
            	        	    // HLSL.g:127:19: ',' exp
            	        	    {
            	        	         this->matchToken(18, &FOLLOW_18_in_function_call615);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefunction_callEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_exp_in_function_call617);
            	        	        exp();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefunction_callEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop19;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop19: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

             this->matchToken(17, &FOLLOW_17_in_function_call625);
            if  (this->hasException())
            {
                goto rulefunction_callEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefunction_callEx; /* Prevent compiler warnings */
    rulefunction_callEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end function_call */

/**
 * $ANTLR start constructor
 * HLSL.g:130:1: constructor : number_type '(' exp ( ',' exp )* ')' ;
 */
void
HLSLParser::constructor()
{
        HLSLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // HLSL.g:131:2: ( number_type '(' exp ( ',' exp )* ')' )
        // HLSL.g:131:4: number_type '(' exp ( ',' exp )* ')'
        {
            this->followPush(FOLLOW_number_type_in_constructor638);
            number_type();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleconstructorEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(16, &FOLLOW_16_in_constructor640);
            if  (this->hasException())
            {
                goto ruleconstructorEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_exp_in_constructor642);
            exp();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleconstructorEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // HLSL.g:131:25: ( ',' exp )*

            for (;;)
            {
                int alt21=2;
                switch ( this->LA(1) )
                {
                case 18:
                	{
                		alt21=1;
                	}
                    break;

                }

                switch (alt21)
                {
            	case 1:
            	    // HLSL.g:131:27: ',' exp
            	    {
            	         this->matchToken(18, &FOLLOW_18_in_constructor647);
            	        if  (this->hasException())
            	        {
            	            goto ruleconstructorEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_exp_in_constructor649);
            	        exp();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleconstructorEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop21;	/* break out of the loop */
            	    break;
                }
            }
            loop21: ; /* Jump out to here if this rule does not match */


             this->matchToken(17, &FOLLOW_17_in_constructor654);
            if  (this->hasException())
            {
                goto ruleconstructorEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleconstructorEx; /* Prevent compiler warnings */
    ruleconstructorEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end constructor */

/**
 * $ANTLR start number
 * HLSL.g:137:1: number : ( FLOAT | INT );
 */
void
HLSLParser::number()
{
        HLSLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // HLSL.g:138:2: ( FLOAT | INT )
        // HLSL.g:
        {
            if ( this->LA(1) == FLOAT || this->LA(1) == INT )
            {
                this->consume();
                this->set_perror_recovery(false);
                 this->set_failedflag(false); 

            }
            else
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                new ANTLR_Exception< HLSLParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
                this->get_exception()->set_expectingSet(NULL);

                goto rulenumberEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenumberEx; /* Prevent compiler warnings */
    rulenumberEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end number */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */



/* End of code
 * =============================================================================
 */
